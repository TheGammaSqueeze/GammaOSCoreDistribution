/* WARNING: This is auto-generated file. Do not modify, since changes will
 * be lost! Modify the generating script instead.
 * This file was generated by /scripts/gen_framework.py
 */
tcu::TestStatus testPhysicalDeviceFeature4444FormatsFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevice4444FormatsFeaturesEXT	device4444FormatsFeaturesEXT[count];
	const bool								is4444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_4444_formats") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&device4444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice4444FormatsFeaturesEXT));
		device4444FormatsFeaturesEXT[ndx].sType = is4444FormatsFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		device4444FormatsFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &device4444FormatsFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (is4444FormatsFeaturesEXT)
		log << TestLog::Message << device4444FormatsFeaturesEXT[0] << TestLog::EndMessage;

	if (is4444FormatsFeaturesEXT &&
		(device4444FormatsFeaturesEXT[0].formatA4R4G4B4 != device4444FormatsFeaturesEXT[1].formatA4R4G4B4 ||
		 device4444FormatsFeaturesEXT[0].formatA4B4G4R4 != device4444FormatsFeaturesEXT[1].formatA4B4G4R4))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevice4444FormatsFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature8BitStorageFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevice8BitStorageFeatures	device8BitStorageFeatures[count];
	const bool							is8BitStorageFeatures = checkExtension(properties, "VK_KHR_8bit_storage") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&device8BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice8BitStorageFeatures));
		device8BitStorageFeatures[ndx].sType = is8BitStorageFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		device8BitStorageFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &device8BitStorageFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (is8BitStorageFeatures)
		log << TestLog::Message << device8BitStorageFeatures[0] << TestLog::EndMessage;

	if (is8BitStorageFeatures &&
		(device8BitStorageFeatures[0].storageBuffer8BitAccess != device8BitStorageFeatures[1].storageBuffer8BitAccess ||
		 device8BitStorageFeatures[0].uniformAndStorageBuffer8BitAccess != device8BitStorageFeatures[1].uniformAndStorageBuffer8BitAccess ||
		 device8BitStorageFeatures[0].storagePushConstant8 != device8BitStorageFeatures[1].storagePushConstant8))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevice8BitStorageFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature16BitStorageFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevice16BitStorageFeatures	device16BitStorageFeatures[count];
	const bool								is16BitStorageFeatures = checkExtension(properties, "VK_KHR_16bit_storage") || context.contextSupports(vk::ApiVersion(1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&device16BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice16BitStorageFeatures));
		device16BitStorageFeatures[ndx].sType = is16BitStorageFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		device16BitStorageFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &device16BitStorageFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (is16BitStorageFeatures)
		log << TestLog::Message << device16BitStorageFeatures[0] << TestLog::EndMessage;

	if (is16BitStorageFeatures &&
		(device16BitStorageFeatures[0].storageBuffer16BitAccess != device16BitStorageFeatures[1].storageBuffer16BitAccess ||
		 device16BitStorageFeatures[0].uniformAndStorageBuffer16BitAccess != device16BitStorageFeatures[1].uniformAndStorageBuffer16BitAccess ||
		 device16BitStorageFeatures[0].storagePushConstant16 != device16BitStorageFeatures[1].storagePushConstant16 ||
		 device16BitStorageFeatures[0].storageInputOutput16 != device16BitStorageFeatures[1].storageInputOutput16))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevice16BitStorageFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureAccelerationStructureFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceAccelerationStructureFeaturesKHR	deviceAccelerationStructureFeaturesKHR[count];
	const bool											isAccelerationStructureFeaturesKHR = checkExtension(properties, "VK_KHR_acceleration_structure");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceAccelerationStructureFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR));
		deviceAccelerationStructureFeaturesKHR[ndx].sType = isAccelerationStructureFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceAccelerationStructureFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceAccelerationStructureFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isAccelerationStructureFeaturesKHR)
		log << TestLog::Message << deviceAccelerationStructureFeaturesKHR[0] << TestLog::EndMessage;

	if (isAccelerationStructureFeaturesKHR &&
		(deviceAccelerationStructureFeaturesKHR[0].accelerationStructure != deviceAccelerationStructureFeaturesKHR[1].accelerationStructure ||
		 deviceAccelerationStructureFeaturesKHR[0].accelerationStructureCaptureReplay != deviceAccelerationStructureFeaturesKHR[1].accelerationStructureCaptureReplay ||
		 deviceAccelerationStructureFeaturesKHR[0].accelerationStructureIndirectBuild != deviceAccelerationStructureFeaturesKHR[1].accelerationStructureIndirectBuild ||
		 deviceAccelerationStructureFeaturesKHR[0].accelerationStructureHostCommands != deviceAccelerationStructureFeaturesKHR[1].accelerationStructureHostCommands ||
		 deviceAccelerationStructureFeaturesKHR[0].descriptorBindingAccelerationStructureUpdateAfterBind != deviceAccelerationStructureFeaturesKHR[1].descriptorBindingAccelerationStructureUpdateAfterBind))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceAccelerationStructureFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureASTCDecodeFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceASTCDecodeFeaturesEXT	deviceASTCDecodeFeaturesEXT[count];
	const bool								isASTCDecodeFeaturesEXT = checkExtension(properties, "VK_EXT_astc_decode_mode");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceASTCDecodeFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT));
		deviceASTCDecodeFeaturesEXT[ndx].sType = isASTCDecodeFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceASTCDecodeFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceASTCDecodeFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isASTCDecodeFeaturesEXT)
		log << TestLog::Message << deviceASTCDecodeFeaturesEXT[0] << TestLog::EndMessage;

	if (isASTCDecodeFeaturesEXT &&
		(deviceASTCDecodeFeaturesEXT[0].decodeModeSharedExponent != deviceASTCDecodeFeaturesEXT[1].decodeModeSharedExponent))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceASTCDecodeFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT	deviceBlendOperationAdvancedFeaturesEXT[count];
	const bool											isBlendOperationAdvancedFeaturesEXT = checkExtension(properties, "VK_EXT_blend_operation_advanced");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceBlendOperationAdvancedFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
		deviceBlendOperationAdvancedFeaturesEXT[ndx].sType = isBlendOperationAdvancedFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceBlendOperationAdvancedFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceBlendOperationAdvancedFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isBlendOperationAdvancedFeaturesEXT)
		log << TestLog::Message << deviceBlendOperationAdvancedFeaturesEXT[0] << TestLog::EndMessage;

	if (isBlendOperationAdvancedFeaturesEXT &&
		(deviceBlendOperationAdvancedFeaturesEXT[0].advancedBlendCoherentOperations != deviceBlendOperationAdvancedFeaturesEXT[1].advancedBlendCoherentOperations))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBufferDeviceAddressFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceBufferDeviceAddressFeaturesEXT	deviceBufferDeviceAddressFeaturesEXT[count];
	const bool										isBufferDeviceAddressFeaturesEXT = checkExtension(properties, "VK_EXT_buffer_device_address");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceBufferDeviceAddressFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT));
		deviceBufferDeviceAddressFeaturesEXT[ndx].sType = isBufferDeviceAddressFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceBufferDeviceAddressFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceBufferDeviceAddressFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isBufferDeviceAddressFeaturesEXT)
		log << TestLog::Message << deviceBufferDeviceAddressFeaturesEXT[0] << TestLog::EndMessage;

	if (isBufferDeviceAddressFeaturesEXT &&
		(deviceBufferDeviceAddressFeaturesEXT[0].bufferDeviceAddress != deviceBufferDeviceAddressFeaturesEXT[1].bufferDeviceAddress ||
		 deviceBufferDeviceAddressFeaturesEXT[0].bufferDeviceAddressCaptureReplay != deviceBufferDeviceAddressFeaturesEXT[1].bufferDeviceAddressCaptureReplay ||
		 deviceBufferDeviceAddressFeaturesEXT[0].bufferDeviceAddressMultiDevice != deviceBufferDeviceAddressFeaturesEXT[1].bufferDeviceAddressMultiDevice))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceBufferDeviceAddressFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBufferDeviceAddressFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceBufferDeviceAddressFeatures	deviceBufferDeviceAddressFeatures[count];
	const bool									isBufferDeviceAddressFeatures = checkExtension(properties, "VK_KHR_buffer_device_address") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceBufferDeviceAddressFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures));
		deviceBufferDeviceAddressFeatures[ndx].sType = isBufferDeviceAddressFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceBufferDeviceAddressFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceBufferDeviceAddressFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isBufferDeviceAddressFeatures)
		log << TestLog::Message << deviceBufferDeviceAddressFeatures[0] << TestLog::EndMessage;

	if (isBufferDeviceAddressFeatures &&
		(deviceBufferDeviceAddressFeatures[0].bufferDeviceAddress != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddress ||
		 deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressCaptureReplay != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressCaptureReplay ||
		 deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressMultiDevice != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressMultiDevice))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceBufferDeviceAddressFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureConditionalRenderingFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceConditionalRenderingFeaturesEXT	deviceConditionalRenderingFeaturesEXT[count];
	const bool										isConditionalRenderingFeaturesEXT = checkExtension(properties, "VK_EXT_conditional_rendering");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceConditionalRenderingFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT));
		deviceConditionalRenderingFeaturesEXT[ndx].sType = isConditionalRenderingFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceConditionalRenderingFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceConditionalRenderingFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isConditionalRenderingFeaturesEXT)
		log << TestLog::Message << deviceConditionalRenderingFeaturesEXT[0] << TestLog::EndMessage;

	if (isConditionalRenderingFeaturesEXT &&
		(deviceConditionalRenderingFeaturesEXT[0].conditionalRendering != deviceConditionalRenderingFeaturesEXT[1].conditionalRendering ||
		 deviceConditionalRenderingFeaturesEXT[0].inheritedConditionalRendering != deviceConditionalRenderingFeaturesEXT[1].inheritedConditionalRendering))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceConditionalRenderingFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceCustomBorderColorFeaturesEXT	deviceCustomBorderColorFeaturesEXT[count];
	const bool										isCustomBorderColorFeaturesEXT = checkExtension(properties, "VK_EXT_custom_border_color");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceCustomBorderColorFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
		deviceCustomBorderColorFeaturesEXT[ndx].sType = isCustomBorderColorFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceCustomBorderColorFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceCustomBorderColorFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isCustomBorderColorFeaturesEXT)
		log << TestLog::Message << deviceCustomBorderColorFeaturesEXT[0] << TestLog::EndMessage;

	if (isCustomBorderColorFeaturesEXT &&
		(deviceCustomBorderColorFeaturesEXT[0].customBorderColors != deviceCustomBorderColorFeaturesEXT[1].customBorderColors ||
		 deviceCustomBorderColorFeaturesEXT[0].customBorderColorWithoutFormat != deviceCustomBorderColorFeaturesEXT[1].customBorderColorWithoutFormat))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceCustomBorderColorFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceColorWriteEnableFeaturesEXT	deviceColorWriteEnableFeaturesEXT[count];
	const bool									isColorWriteEnableFeaturesEXT = checkExtension(properties, "VK_EXT_color_write_enable");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceColorWriteEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT));
		deviceColorWriteEnableFeaturesEXT[ndx].sType = isColorWriteEnableFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceColorWriteEnableFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceColorWriteEnableFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isColorWriteEnableFeaturesEXT)
		log << TestLog::Message << deviceColorWriteEnableFeaturesEXT[0] << TestLog::EndMessage;

	if (isColorWriteEnableFeaturesEXT &&
		(deviceColorWriteEnableFeaturesEXT[0].colorWriteEnable != deviceColorWriteEnableFeaturesEXT[1].colorWriteEnable))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceColorWriteEnableFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDescriptorIndexingFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceDescriptorIndexingFeatures	deviceDescriptorIndexingFeatures[count];
	const bool									isDescriptorIndexingFeatures = checkExtension(properties, "VK_EXT_descriptor_indexing") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceDescriptorIndexingFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDescriptorIndexingFeatures));
		deviceDescriptorIndexingFeatures[ndx].sType = isDescriptorIndexingFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceDescriptorIndexingFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceDescriptorIndexingFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isDescriptorIndexingFeatures)
		log << TestLog::Message << deviceDescriptorIndexingFeatures[0] << TestLog::EndMessage;

	if (isDescriptorIndexingFeatures &&
		(deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayDynamicIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayDynamicIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayDynamicIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderUniformBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderSampledImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderSampledImageArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageImageArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayNonUniformIndexing ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingUniformBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingSampledImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingSampledImageUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingStorageImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageImageUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingStorageBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingUniformTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformTexelBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingStorageTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageTexelBufferUpdateAfterBind ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingUpdateUnusedWhilePending != deviceDescriptorIndexingFeatures[1].descriptorBindingUpdateUnusedWhilePending ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingPartiallyBound != deviceDescriptorIndexingFeatures[1].descriptorBindingPartiallyBound ||
		 deviceDescriptorIndexingFeatures[0].descriptorBindingVariableDescriptorCount != deviceDescriptorIndexingFeatures[1].descriptorBindingVariableDescriptorCount ||
		 deviceDescriptorIndexingFeatures[0].runtimeDescriptorArray != deviceDescriptorIndexingFeatures[1].runtimeDescriptorArray))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceDescriptorIndexingFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceDepthClipEnableFeaturesEXT	deviceDepthClipEnableFeaturesEXT[count];
	const bool									isDepthClipEnableFeaturesEXT = checkExtension(properties, "VK_EXT_depth_clip_enable");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceDepthClipEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT));
		deviceDepthClipEnableFeaturesEXT[ndx].sType = isDepthClipEnableFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceDepthClipEnableFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceDepthClipEnableFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isDepthClipEnableFeaturesEXT)
		log << TestLog::Message << deviceDepthClipEnableFeaturesEXT[0] << TestLog::EndMessage;

	if (isDepthClipEnableFeaturesEXT &&
		(deviceDepthClipEnableFeaturesEXT[0].depthClipEnable != deviceDepthClipEnableFeaturesEXT[1].depthClipEnable))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceDepthClipEnableFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDynamicRenderingFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceDynamicRenderingFeatures	deviceDynamicRenderingFeatures[count];
	const bool									isDynamicRenderingFeatures = checkExtension(properties, "VK_KHR_dynamic_rendering") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceDynamicRenderingFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDynamicRenderingFeatures));
		deviceDynamicRenderingFeatures[ndx].sType = isDynamicRenderingFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceDynamicRenderingFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceDynamicRenderingFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isDynamicRenderingFeatures)
		log << TestLog::Message << deviceDynamicRenderingFeatures[0] << TestLog::EndMessage;

	if (isDynamicRenderingFeatures &&
		(deviceDynamicRenderingFeatures[0].dynamicRendering != deviceDynamicRenderingFeatures[1].dynamicRendering))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceDynamicRenderingFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceExtendedDynamicStateFeaturesEXT	deviceExtendedDynamicStateFeaturesEXT[count];
	const bool										isExtendedDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceExtendedDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT));
		deviceExtendedDynamicStateFeaturesEXT[ndx].sType = isExtendedDynamicStateFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceExtendedDynamicStateFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceExtendedDynamicStateFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isExtendedDynamicStateFeaturesEXT)
		log << TestLog::Message << deviceExtendedDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

	if (isExtendedDynamicStateFeaturesEXT &&
		(deviceExtendedDynamicStateFeaturesEXT[0].extendedDynamicState != deviceExtendedDynamicStateFeaturesEXT[1].extendedDynamicState))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicStateFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceExtendedDynamicState2FeaturesEXT	deviceExtendedDynamicState2FeaturesEXT[count];
	const bool											isExtendedDynamicState2FeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state2");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceExtendedDynamicState2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT));
		deviceExtendedDynamicState2FeaturesEXT[ndx].sType = isExtendedDynamicState2FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceExtendedDynamicState2FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceExtendedDynamicState2FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isExtendedDynamicState2FeaturesEXT)
		log << TestLog::Message << deviceExtendedDynamicState2FeaturesEXT[0] << TestLog::EndMessage;

	if (isExtendedDynamicState2FeaturesEXT &&
		(deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2 != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2 ||
		 deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2LogicOp != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2LogicOp ||
		 deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2PatchControlPoints != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2PatchControlPoints))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicState2FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentDensityMapFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceFragmentDensityMapFeaturesEXT	deviceFragmentDensityMapFeaturesEXT[count];
	const bool										isFragmentDensityMapFeaturesEXT = checkExtension(properties, "VK_EXT_fragment_density_map");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceFragmentDensityMapFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT));
		deviceFragmentDensityMapFeaturesEXT[ndx].sType = isFragmentDensityMapFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceFragmentDensityMapFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceFragmentDensityMapFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isFragmentDensityMapFeaturesEXT)
		log << TestLog::Message << deviceFragmentDensityMapFeaturesEXT[0] << TestLog::EndMessage;

	if (isFragmentDensityMapFeaturesEXT &&
		(deviceFragmentDensityMapFeaturesEXT[0].fragmentDensityMap != deviceFragmentDensityMapFeaturesEXT[1].fragmentDensityMap ||
		 deviceFragmentDensityMapFeaturesEXT[0].fragmentDensityMapDynamic != deviceFragmentDensityMapFeaturesEXT[1].fragmentDensityMapDynamic ||
		 deviceFragmentDensityMapFeaturesEXT[0].fragmentDensityMapNonSubsampledImages != deviceFragmentDensityMapFeaturesEXT[1].fragmentDensityMapNonSubsampledImages))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentDensityMapFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentDensityMap2FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceFragmentDensityMap2FeaturesEXT	deviceFragmentDensityMap2FeaturesEXT[count];
	const bool										isFragmentDensityMap2FeaturesEXT = checkExtension(properties, "VK_EXT_fragment_density_map2");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceFragmentDensityMap2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT));
		deviceFragmentDensityMap2FeaturesEXT[ndx].sType = isFragmentDensityMap2FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceFragmentDensityMap2FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceFragmentDensityMap2FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isFragmentDensityMap2FeaturesEXT)
		log << TestLog::Message << deviceFragmentDensityMap2FeaturesEXT[0] << TestLog::EndMessage;

	if (isFragmentDensityMap2FeaturesEXT &&
		(deviceFragmentDensityMap2FeaturesEXT[0].fragmentDensityMapDeferred != deviceFragmentDensityMap2FeaturesEXT[1].fragmentDensityMapDeferred))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentDensityMap2FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceFragmentShadingRateFeaturesKHR	deviceFragmentShadingRateFeaturesKHR[count];
	const bool										isFragmentShadingRateFeaturesKHR = checkExtension(properties, "VK_KHR_fragment_shading_rate");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceFragmentShadingRateFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR));
		deviceFragmentShadingRateFeaturesKHR[ndx].sType = isFragmentShadingRateFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceFragmentShadingRateFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceFragmentShadingRateFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isFragmentShadingRateFeaturesKHR)
		log << TestLog::Message << deviceFragmentShadingRateFeaturesKHR[0] << TestLog::EndMessage;

	if (isFragmentShadingRateFeaturesKHR &&
		(deviceFragmentShadingRateFeaturesKHR[0].pipelineFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].pipelineFragmentShadingRate ||
		 deviceFragmentShadingRateFeaturesKHR[0].primitiveFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].primitiveFragmentShadingRate ||
		 deviceFragmentShadingRateFeaturesKHR[0].attachmentFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].attachmentFragmentShadingRate))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShadingRateFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureGlobalPriorityQueryFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR	deviceGlobalPriorityQueryFeaturesKHR[count];
	const bool										isGlobalPriorityQueryFeaturesKHR = checkExtension(properties, "VK_KHR_global_priority");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceGlobalPriorityQueryFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR));
		deviceGlobalPriorityQueryFeaturesKHR[ndx].sType = isGlobalPriorityQueryFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceGlobalPriorityQueryFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceGlobalPriorityQueryFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isGlobalPriorityQueryFeaturesKHR)
		log << TestLog::Message << deviceGlobalPriorityQueryFeaturesKHR[0] << TestLog::EndMessage;

	if (isGlobalPriorityQueryFeaturesKHR &&
		(deviceGlobalPriorityQueryFeaturesKHR[0].globalPriorityQuery != deviceGlobalPriorityQueryFeaturesKHR[1].globalPriorityQuery))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureInlineUniformBlockFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceInlineUniformBlockFeatures	deviceInlineUniformBlockFeatures[count];
	const bool									isInlineUniformBlockFeatures = checkExtension(properties, "VK_EXT_inline_uniform_block") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceInlineUniformBlockFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceInlineUniformBlockFeatures));
		deviceInlineUniformBlockFeatures[ndx].sType = isInlineUniformBlockFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceInlineUniformBlockFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceInlineUniformBlockFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isInlineUniformBlockFeatures)
		log << TestLog::Message << deviceInlineUniformBlockFeatures[0] << TestLog::EndMessage;

	if (isInlineUniformBlockFeatures &&
		(deviceInlineUniformBlockFeatures[0].inlineUniformBlock != deviceInlineUniformBlockFeatures[1].inlineUniformBlock ||
		 deviceInlineUniformBlockFeatures[0].descriptorBindingInlineUniformBlockUpdateAfterBind != deviceInlineUniformBlockFeatures[1].descriptorBindingInlineUniformBlockUpdateAfterBind))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceInlineUniformBlockFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureIndexTypeUint8FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceIndexTypeUint8FeaturesEXT	deviceIndexTypeUint8FeaturesEXT[count];
	const bool									isIndexTypeUint8FeaturesEXT = checkExtension(properties, "VK_EXT_index_type_uint8");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceIndexTypeUint8FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT));
		deviceIndexTypeUint8FeaturesEXT[ndx].sType = isIndexTypeUint8FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceIndexTypeUint8FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceIndexTypeUint8FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isIndexTypeUint8FeaturesEXT)
		log << TestLog::Message << deviceIndexTypeUint8FeaturesEXT[0] << TestLog::EndMessage;

	if (isIndexTypeUint8FeaturesEXT &&
		(deviceIndexTypeUint8FeaturesEXT[0].indexTypeUint8 != deviceIndexTypeUint8FeaturesEXT[1].indexTypeUint8))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceIndexTypeUint8FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureImagelessFramebufferFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceImagelessFramebufferFeatures	deviceImagelessFramebufferFeatures[count];
	const bool										isImagelessFramebufferFeatures = checkExtension(properties, "VK_KHR_imageless_framebuffer") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceImagelessFramebufferFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceImagelessFramebufferFeatures));
		deviceImagelessFramebufferFeatures[ndx].sType = isImagelessFramebufferFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceImagelessFramebufferFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceImagelessFramebufferFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isImagelessFramebufferFeatures)
		log << TestLog::Message << deviceImagelessFramebufferFeatures[0] << TestLog::EndMessage;

	if (isImagelessFramebufferFeatures &&
		(deviceImagelessFramebufferFeatures[0].imagelessFramebuffer != deviceImagelessFramebufferFeatures[1].imagelessFramebuffer))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceImagelessFramebufferFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureImageRobustnessFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceImageRobustnessFeatures	deviceImageRobustnessFeatures[count];
	const bool								isImageRobustnessFeatures = checkExtension(properties, "VK_EXT_image_robustness") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceImageRobustnessFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceImageRobustnessFeatures));
		deviceImageRobustnessFeatures[ndx].sType = isImageRobustnessFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceImageRobustnessFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceImageRobustnessFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isImageRobustnessFeatures)
		log << TestLog::Message << deviceImageRobustnessFeatures[0] << TestLog::EndMessage;

	if (isImageRobustnessFeatures &&
		(deviceImageRobustnessFeatures[0].robustImageAccess != deviceImageRobustnessFeatures[1].robustImageAccess))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceImageRobustnessFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureHostQueryResetFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceHostQueryResetFeatures	deviceHostQueryResetFeatures[count];
	const bool								isHostQueryResetFeatures = checkExtension(properties, "VK_EXT_host_query_reset") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceHostQueryResetFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceHostQueryResetFeatures));
		deviceHostQueryResetFeatures[ndx].sType = isHostQueryResetFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceHostQueryResetFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceHostQueryResetFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isHostQueryResetFeatures)
		log << TestLog::Message << deviceHostQueryResetFeatures[0] << TestLog::EndMessage;

	if (isHostQueryResetFeatures &&
		(deviceHostQueryResetFeatures[0].hostQueryReset != deviceHostQueryResetFeatures[1].hostQueryReset))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceHostQueryResetFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureLineRasterizationFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceLineRasterizationFeaturesEXT	deviceLineRasterizationFeaturesEXT[count];
	const bool										isLineRasterizationFeaturesEXT = checkExtension(properties, "VK_EXT_line_rasterization");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceLineRasterizationFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT));
		deviceLineRasterizationFeaturesEXT[ndx].sType = isLineRasterizationFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceLineRasterizationFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceLineRasterizationFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isLineRasterizationFeaturesEXT)
		log << TestLog::Message << deviceLineRasterizationFeaturesEXT[0] << TestLog::EndMessage;

	if (isLineRasterizationFeaturesEXT &&
		(deviceLineRasterizationFeaturesEXT[0].rectangularLines != deviceLineRasterizationFeaturesEXT[1].rectangularLines ||
		 deviceLineRasterizationFeaturesEXT[0].bresenhamLines != deviceLineRasterizationFeaturesEXT[1].bresenhamLines ||
		 deviceLineRasterizationFeaturesEXT[0].smoothLines != deviceLineRasterizationFeaturesEXT[1].smoothLines ||
		 deviceLineRasterizationFeaturesEXT[0].stippledRectangularLines != deviceLineRasterizationFeaturesEXT[1].stippledRectangularLines ||
		 deviceLineRasterizationFeaturesEXT[0].stippledBresenhamLines != deviceLineRasterizationFeaturesEXT[1].stippledBresenhamLines ||
		 deviceLineRasterizationFeaturesEXT[0].stippledSmoothLines != deviceLineRasterizationFeaturesEXT[1].stippledSmoothLines))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceLineRasterizationFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMaintenance4Features (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceMaintenance4Features	deviceMaintenance4Features[count];
	const bool								isMaintenance4Features = checkExtension(properties, "VK_KHR_maintenance4") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceMaintenance4Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMaintenance4Features));
		deviceMaintenance4Features[ndx].sType = isMaintenance4Features ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceMaintenance4Features[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceMaintenance4Features[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isMaintenance4Features)
		log << TestLog::Message << deviceMaintenance4Features[0] << TestLog::EndMessage;

	if (isMaintenance4Features &&
		(deviceMaintenance4Features[0].maintenance4 != deviceMaintenance4Features[1].maintenance4))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceMaintenance4Features");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMultiviewFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceMultiviewFeatures	deviceMultiviewFeatures[count];
	const bool							isMultiviewFeatures = checkExtension(properties, "VK_KHR_multiview") || context.contextSupports(vk::ApiVersion(1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceMultiviewFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMultiviewFeatures));
		deviceMultiviewFeatures[ndx].sType = isMultiviewFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceMultiviewFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceMultiviewFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isMultiviewFeatures)
		log << TestLog::Message << deviceMultiviewFeatures[0] << TestLog::EndMessage;

	if (isMultiviewFeatures &&
		(deviceMultiviewFeatures[0].multiview != deviceMultiviewFeatures[1].multiview ||
		 deviceMultiviewFeatures[0].multiviewGeometryShader != deviceMultiviewFeatures[1].multiviewGeometryShader ||
		 deviceMultiviewFeatures[0].multiviewTessellationShader != deviceMultiviewFeatures[1].multiviewTessellationShader))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceMultiviewFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMultiDrawFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceMultiDrawFeaturesEXT	deviceMultiDrawFeaturesEXT[count];
	const bool								isMultiDrawFeaturesEXT = checkExtension(properties, "VK_EXT_multi_draw");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceMultiDrawFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT));
		deviceMultiDrawFeaturesEXT[ndx].sType = isMultiDrawFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceMultiDrawFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceMultiDrawFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isMultiDrawFeaturesEXT)
		log << TestLog::Message << deviceMultiDrawFeaturesEXT[0] << TestLog::EndMessage;

	if (isMultiDrawFeaturesEXT &&
		(deviceMultiDrawFeaturesEXT[0].multiDraw != deviceMultiDrawFeaturesEXT[1].multiDraw))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceMultiDrawFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMemoryPriorityFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceMemoryPriorityFeaturesEXT	deviceMemoryPriorityFeaturesEXT[count];
	const bool									isMemoryPriorityFeaturesEXT = checkExtension(properties, "VK_EXT_memory_priority");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceMemoryPriorityFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT));
		deviceMemoryPriorityFeaturesEXT[ndx].sType = isMemoryPriorityFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceMemoryPriorityFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceMemoryPriorityFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isMemoryPriorityFeaturesEXT)
		log << TestLog::Message << deviceMemoryPriorityFeaturesEXT[0] << TestLog::EndMessage;

	if (isMemoryPriorityFeaturesEXT &&
		(deviceMemoryPriorityFeaturesEXT[0].memoryPriority != deviceMemoryPriorityFeaturesEXT[1].memoryPriority))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceMemoryPriorityFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDeviceMemoryReportFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceDeviceMemoryReportFeaturesEXT	deviceDeviceMemoryReportFeaturesEXT[count];
	const bool										isDeviceMemoryReportFeaturesEXT = checkExtension(properties, "VK_EXT_device_memory_report");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceDeviceMemoryReportFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT));
		deviceDeviceMemoryReportFeaturesEXT[ndx].sType = isDeviceMemoryReportFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceDeviceMemoryReportFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceDeviceMemoryReportFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isDeviceMemoryReportFeaturesEXT)
		log << TestLog::Message << deviceDeviceMemoryReportFeaturesEXT[0] << TestLog::EndMessage;

	if (isDeviceMemoryReportFeaturesEXT &&
		(deviceDeviceMemoryReportFeaturesEXT[0].deviceMemoryReport != deviceDeviceMemoryReportFeaturesEXT[1].deviceMemoryReport))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceDeviceMemoryReportFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePerformanceQueryFeaturesKHR	devicePerformanceQueryFeaturesKHR[count];
	const bool									isPerformanceQueryFeaturesKHR = checkExtension(properties, "VK_KHR_performance_query");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePerformanceQueryFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR));
		devicePerformanceQueryFeaturesKHR[ndx].sType = isPerformanceQueryFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePerformanceQueryFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePerformanceQueryFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPerformanceQueryFeaturesKHR)
		log << TestLog::Message << devicePerformanceQueryFeaturesKHR[0] << TestLog::EndMessage;

	if (isPerformanceQueryFeaturesKHR &&
		(devicePerformanceQueryFeaturesKHR[0].performanceCounterQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterQueryPools ||
		 devicePerformanceQueryFeaturesKHR[0].performanceCounterMultipleQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterMultipleQueryPools))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePerformanceQueryFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePipelineCreationCacheControlFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePipelineCreationCacheControlFeatures	devicePipelineCreationCacheControlFeatures[count];
	const bool												isPipelineCreationCacheControlFeatures = checkExtension(properties, "VK_EXT_pipeline_creation_cache_control") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePipelineCreationCacheControlFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures));
		devicePipelineCreationCacheControlFeatures[ndx].sType = isPipelineCreationCacheControlFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePipelineCreationCacheControlFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePipelineCreationCacheControlFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPipelineCreationCacheControlFeatures)
		log << TestLog::Message << devicePipelineCreationCacheControlFeatures[0] << TestLog::EndMessage;

	if (isPipelineCreationCacheControlFeatures &&
		(devicePipelineCreationCacheControlFeatures[0].pipelineCreationCacheControl != devicePipelineCreationCacheControlFeatures[1].pipelineCreationCacheControl))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePipelineCreationCacheControlFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePipelineExecutablePropertiesFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR	devicePipelineExecutablePropertiesFeaturesKHR[count];
	const bool												isPipelineExecutablePropertiesFeaturesKHR = checkExtension(properties, "VK_KHR_pipeline_executable_properties");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePipelineExecutablePropertiesFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR));
		devicePipelineExecutablePropertiesFeaturesKHR[ndx].sType = isPipelineExecutablePropertiesFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePipelineExecutablePropertiesFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePipelineExecutablePropertiesFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPipelineExecutablePropertiesFeaturesKHR)
		log << TestLog::Message << devicePipelineExecutablePropertiesFeaturesKHR[0] << TestLog::EndMessage;

	if (isPipelineExecutablePropertiesFeaturesKHR &&
		(devicePipelineExecutablePropertiesFeaturesKHR[0].pipelineExecutableInfo != devicePipelineExecutablePropertiesFeaturesKHR[1].pipelineExecutableInfo))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePresentIdFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePresentIdFeaturesKHR	devicePresentIdFeaturesKHR[count];
	const bool								isPresentIdFeaturesKHR = checkExtension(properties, "VK_KHR_present_id");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePresentIdFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePresentIdFeaturesKHR));
		devicePresentIdFeaturesKHR[ndx].sType = isPresentIdFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePresentIdFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePresentIdFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPresentIdFeaturesKHR)
		log << TestLog::Message << devicePresentIdFeaturesKHR[0] << TestLog::EndMessage;

	if (isPresentIdFeaturesKHR &&
		(devicePresentIdFeaturesKHR[0].presentId != devicePresentIdFeaturesKHR[1].presentId))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePresentIdFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePresentWaitFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePresentWaitFeaturesKHR	devicePresentWaitFeaturesKHR[count];
	const bool								isPresentWaitFeaturesKHR = checkExtension(properties, "VK_KHR_present_wait");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePresentWaitFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePresentWaitFeaturesKHR));
		devicePresentWaitFeaturesKHR[ndx].sType = isPresentWaitFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePresentWaitFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePresentWaitFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPresentWaitFeaturesKHR)
		log << TestLog::Message << devicePresentWaitFeaturesKHR[0] << TestLog::EndMessage;

	if (isPresentWaitFeaturesKHR &&
		(devicePresentWaitFeaturesKHR[0].presentWait != devicePresentWaitFeaturesKHR[1].presentWait))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePresentWaitFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureProtectedMemoryFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceProtectedMemoryFeatures	deviceProtectedMemoryFeatures[count];
	const bool								isProtectedMemoryFeatures = context.contextSupports(vk::ApiVersion(1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceProtectedMemoryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
		deviceProtectedMemoryFeatures[ndx].sType = isProtectedMemoryFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceProtectedMemoryFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceProtectedMemoryFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isProtectedMemoryFeatures)
		log << TestLog::Message << deviceProtectedMemoryFeatures[0] << TestLog::EndMessage;

	if (isProtectedMemoryFeatures &&
		(deviceProtectedMemoryFeatures[0].protectedMemory != deviceProtectedMemoryFeatures[1].protectedMemory))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceProtectedMemoryFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureProvokingVertexFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceProvokingVertexFeaturesEXT	deviceProvokingVertexFeaturesEXT[count];
	const bool									isProvokingVertexFeaturesEXT = checkExtension(properties, "VK_EXT_provoking_vertex");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceProvokingVertexFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT));
		deviceProvokingVertexFeaturesEXT[ndx].sType = isProvokingVertexFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceProvokingVertexFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceProvokingVertexFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isProvokingVertexFeaturesEXT)
		log << TestLog::Message << deviceProvokingVertexFeaturesEXT[0] << TestLog::EndMessage;

	if (isProvokingVertexFeaturesEXT &&
		(deviceProvokingVertexFeaturesEXT[0].provokingVertexLast != deviceProvokingVertexFeaturesEXT[1].provokingVertexLast ||
		 deviceProvokingVertexFeaturesEXT[0].transformFeedbackPreservesProvokingVertex != deviceProvokingVertexFeaturesEXT[1].transformFeedbackPreservesProvokingVertex))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceProvokingVertexFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePrimitiveTopologyListRestartFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT	devicePrimitiveTopologyListRestartFeaturesEXT[count];
	const bool												isPrimitiveTopologyListRestartFeaturesEXT = checkExtension(properties, "VK_EXT_primitive_topology_list_restart");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePrimitiveTopologyListRestartFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT));
		devicePrimitiveTopologyListRestartFeaturesEXT[ndx].sType = isPrimitiveTopologyListRestartFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePrimitiveTopologyListRestartFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePrimitiveTopologyListRestartFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPrimitiveTopologyListRestartFeaturesEXT)
		log << TestLog::Message << devicePrimitiveTopologyListRestartFeaturesEXT[0] << TestLog::EndMessage;

	if (isPrimitiveTopologyListRestartFeaturesEXT &&
		(devicePrimitiveTopologyListRestartFeaturesEXT[0].primitiveTopologyListRestart != devicePrimitiveTopologyListRestartFeaturesEXT[1].primitiveTopologyListRestart ||
		 devicePrimitiveTopologyListRestartFeaturesEXT[0].primitiveTopologyPatchListRestart != devicePrimitiveTopologyListRestartFeaturesEXT[1].primitiveTopologyPatchListRestart))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePrivateDataFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDevicePrivateDataFeatures	devicePrivateDataFeatures[count];
	const bool							isPrivateDataFeatures = checkExtension(properties, "VK_EXT_private_data") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&devicePrivateDataFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePrivateDataFeatures));
		devicePrivateDataFeatures[ndx].sType = isPrivateDataFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		devicePrivateDataFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &devicePrivateDataFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isPrivateDataFeatures)
		log << TestLog::Message << devicePrivateDataFeatures[0] << TestLog::EndMessage;

	if (isPrivateDataFeatures &&
		(devicePrivateDataFeatures[0].privateData != devicePrivateDataFeatures[1].privateData))
	{
		TCU_FAIL("Mismatch between VkPhysicalDevicePrivateDataFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureRayTracingPipelineFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceRayTracingPipelineFeaturesKHR	deviceRayTracingPipelineFeaturesKHR[count];
	const bool										isRayTracingPipelineFeaturesKHR = checkExtension(properties, "VK_KHR_ray_tracing_pipeline");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceRayTracingPipelineFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR));
		deviceRayTracingPipelineFeaturesKHR[ndx].sType = isRayTracingPipelineFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceRayTracingPipelineFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceRayTracingPipelineFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isRayTracingPipelineFeaturesKHR)
		log << TestLog::Message << deviceRayTracingPipelineFeaturesKHR[0] << TestLog::EndMessage;

	if (isRayTracingPipelineFeaturesKHR &&
		(deviceRayTracingPipelineFeaturesKHR[0].rayTracingPipeline != deviceRayTracingPipelineFeaturesKHR[1].rayTracingPipeline ||
		 deviceRayTracingPipelineFeaturesKHR[0].rayTracingPipelineShaderGroupHandleCaptureReplay != deviceRayTracingPipelineFeaturesKHR[1].rayTracingPipelineShaderGroupHandleCaptureReplay ||
		 deviceRayTracingPipelineFeaturesKHR[0].rayTracingPipelineShaderGroupHandleCaptureReplayMixed != deviceRayTracingPipelineFeaturesKHR[1].rayTracingPipelineShaderGroupHandleCaptureReplayMixed ||
		 deviceRayTracingPipelineFeaturesKHR[0].rayTracingPipelineTraceRaysIndirect != deviceRayTracingPipelineFeaturesKHR[1].rayTracingPipelineTraceRaysIndirect ||
		 deviceRayTracingPipelineFeaturesKHR[0].rayTraversalPrimitiveCulling != deviceRayTracingPipelineFeaturesKHR[1].rayTraversalPrimitiveCulling))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceRayTracingPipelineFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureRayQueryFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceRayQueryFeaturesKHR	deviceRayQueryFeaturesKHR[count];
	const bool							isRayQueryFeaturesKHR = checkExtension(properties, "VK_KHR_ray_query");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceRayQueryFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceRayQueryFeaturesKHR));
		deviceRayQueryFeaturesKHR[ndx].sType = isRayQueryFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceRayQueryFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceRayQueryFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isRayQueryFeaturesKHR)
		log << TestLog::Message << deviceRayQueryFeaturesKHR[0] << TestLog::EndMessage;

	if (isRayQueryFeaturesKHR &&
		(deviceRayQueryFeaturesKHR[0].rayQuery != deviceRayQueryFeaturesKHR[1].rayQuery))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceRayQueryFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureRobustness2FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceRobustness2FeaturesEXT	deviceRobustness2FeaturesEXT[count];
	const bool								isRobustness2FeaturesEXT = checkExtension(properties, "VK_EXT_robustness2");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceRobustness2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceRobustness2FeaturesEXT));
		deviceRobustness2FeaturesEXT[ndx].sType = isRobustness2FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceRobustness2FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceRobustness2FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isRobustness2FeaturesEXT)
		log << TestLog::Message << deviceRobustness2FeaturesEXT[0] << TestLog::EndMessage;

	if (isRobustness2FeaturesEXT &&
		(deviceRobustness2FeaturesEXT[0].robustBufferAccess2 != deviceRobustness2FeaturesEXT[1].robustBufferAccess2 ||
		 deviceRobustness2FeaturesEXT[0].robustImageAccess2 != deviceRobustness2FeaturesEXT[1].robustImageAccess2 ||
		 deviceRobustness2FeaturesEXT[0].nullDescriptor != deviceRobustness2FeaturesEXT[1].nullDescriptor))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceRobustness2FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceSamplerYcbcrConversionFeatures	deviceSamplerYcbcrConversionFeatures[count];
	const bool										isSamplerYcbcrConversionFeatures = checkExtension(properties, "VK_KHR_sampler_ycbcr_conversion") || context.contextSupports(vk::ApiVersion(1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceSamplerYcbcrConversionFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
		deviceSamplerYcbcrConversionFeatures[ndx].sType = isSamplerYcbcrConversionFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceSamplerYcbcrConversionFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceSamplerYcbcrConversionFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isSamplerYcbcrConversionFeatures)
		log << TestLog::Message << deviceSamplerYcbcrConversionFeatures[0] << TestLog::EndMessage;

	if (isSamplerYcbcrConversionFeatures &&
		(deviceSamplerYcbcrConversionFeatures[0].samplerYcbcrConversion != deviceSamplerYcbcrConversionFeatures[1].samplerYcbcrConversion))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceSamplerYcbcrConversionFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureScalarBlockLayoutFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceScalarBlockLayoutFeatures	deviceScalarBlockLayoutFeatures[count];
	const bool									isScalarBlockLayoutFeatures = checkExtension(properties, "VK_EXT_scalar_block_layout") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceScalarBlockLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures));
		deviceScalarBlockLayoutFeatures[ndx].sType = isScalarBlockLayoutFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceScalarBlockLayoutFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceScalarBlockLayoutFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isScalarBlockLayoutFeatures)
		log << TestLog::Message << deviceScalarBlockLayoutFeatures[0] << TestLog::EndMessage;

	if (isScalarBlockLayoutFeatures &&
		(deviceScalarBlockLayoutFeatures[0].scalarBlockLayout != deviceScalarBlockLayoutFeatures[1].scalarBlockLayout))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceScalarBlockLayoutFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures	deviceSeparateDepthStencilLayoutsFeatures[count];
	const bool											isSeparateDepthStencilLayoutsFeatures = checkExtension(properties, "VK_KHR_separate_depth_stencil_layouts") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceSeparateDepthStencilLayoutsFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures));
		deviceSeparateDepthStencilLayoutsFeatures[ndx].sType = isSeparateDepthStencilLayoutsFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceSeparateDepthStencilLayoutsFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceSeparateDepthStencilLayoutsFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isSeparateDepthStencilLayoutsFeatures)
		log << TestLog::Message << deviceSeparateDepthStencilLayoutsFeatures[0] << TestLog::EndMessage;

	if (isSeparateDepthStencilLayoutsFeatures &&
		(deviceSeparateDepthStencilLayoutsFeatures[0].separateDepthStencilLayouts != deviceSeparateDepthStencilLayoutsFeatures[1].separateDepthStencilLayouts))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicInt64Features (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderAtomicInt64Features	deviceShaderAtomicInt64Features[count];
	const bool									isShaderAtomicInt64Features = checkExtension(properties, "VK_KHR_shader_atomic_int64") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderAtomicInt64Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicInt64Features));
		deviceShaderAtomicInt64Features[ndx].sType = isShaderAtomicInt64Features ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderAtomicInt64Features[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderAtomicInt64Features[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderAtomicInt64Features)
		log << TestLog::Message << deviceShaderAtomicInt64Features[0] << TestLog::EndMessage;

	if (isShaderAtomicInt64Features &&
		(deviceShaderAtomicInt64Features[0].shaderBufferInt64Atomics != deviceShaderAtomicInt64Features[1].shaderBufferInt64Atomics ||
		 deviceShaderAtomicInt64Features[0].shaderSharedInt64Atomics != deviceShaderAtomicInt64Features[1].shaderSharedInt64Atomics))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicInt64Features");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderAtomicFloatFeaturesEXT	deviceShaderAtomicFloatFeaturesEXT[count];
	const bool										isShaderAtomicFloatFeaturesEXT = checkExtension(properties, "VK_EXT_shader_atomic_float");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderAtomicFloatFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT));
		deviceShaderAtomicFloatFeaturesEXT[ndx].sType = isShaderAtomicFloatFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderAtomicFloatFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderAtomicFloatFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderAtomicFloatFeaturesEXT)
		log << TestLog::Message << deviceShaderAtomicFloatFeaturesEXT[0] << TestLog::EndMessage;

	if (isShaderAtomicFloatFeaturesEXT &&
		(deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32AtomicAdd ||
		 deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32Atomics ||
		 deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32AtomicAdd))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicFloatFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicFloat2FeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT	deviceShaderAtomicFloat2FeaturesEXT[count];
	const bool										isShaderAtomicFloat2FeaturesEXT = checkExtension(properties, "VK_EXT_shader_atomic_float2");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderAtomicFloat2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT));
		deviceShaderAtomicFloat2FeaturesEXT[ndx].sType = isShaderAtomicFloat2FeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderAtomicFloat2FeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderAtomicFloat2FeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderAtomicFloat2FeaturesEXT)
		log << TestLog::Message << deviceShaderAtomicFloat2FeaturesEXT[0] << TestLog::EndMessage;

	if (isShaderAtomicFloat2FeaturesEXT &&
		(deviceShaderAtomicFloat2FeaturesEXT[0].shaderBufferFloat16Atomics != deviceShaderAtomicFloat2FeaturesEXT[1].shaderBufferFloat16Atomics ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderBufferFloat16AtomicAdd != deviceShaderAtomicFloat2FeaturesEXT[1].shaderBufferFloat16AtomicAdd ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderBufferFloat16AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].shaderBufferFloat16AtomicMinMax ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderBufferFloat32AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].shaderBufferFloat32AtomicMinMax ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderBufferFloat64AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].shaderBufferFloat64AtomicMinMax ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderSharedFloat16Atomics != deviceShaderAtomicFloat2FeaturesEXT[1].shaderSharedFloat16Atomics ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderSharedFloat16AtomicAdd != deviceShaderAtomicFloat2FeaturesEXT[1].shaderSharedFloat16AtomicAdd ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderSharedFloat16AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].shaderSharedFloat16AtomicMinMax ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderSharedFloat32AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].shaderSharedFloat32AtomicMinMax ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderSharedFloat64AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].shaderSharedFloat64AtomicMinMax ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].shaderImageFloat32AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].shaderImageFloat32AtomicMinMax ||
		 deviceShaderAtomicFloat2FeaturesEXT[0].sparseImageFloat32AtomicMinMax != deviceShaderAtomicFloat2FeaturesEXT[1].sparseImageFloat32AtomicMinMax))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderFloat16Int8Features (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderFloat16Int8Features	deviceShaderFloat16Int8Features[count];
	const bool									isShaderFloat16Int8Features = checkExtension(properties, "VK_KHR_shader_float16_int8") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderFloat16Int8Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderFloat16Int8Features));
		deviceShaderFloat16Int8Features[ndx].sType = isShaderFloat16Int8Features ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderFloat16Int8Features[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderFloat16Int8Features[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderFloat16Int8Features)
		log << TestLog::Message << deviceShaderFloat16Int8Features[0] << TestLog::EndMessage;

	if (isShaderFloat16Int8Features &&
		(deviceShaderFloat16Int8Features[0].shaderFloat16 != deviceShaderFloat16Int8Features[1].shaderFloat16 ||
		 deviceShaderFloat16Int8Features[0].shaderInt8 != deviceShaderFloat16Int8Features[1].shaderInt8))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderFloat16Int8Features");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderClockFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderClockFeaturesKHR	deviceShaderClockFeaturesKHR[count];
	const bool								isShaderClockFeaturesKHR = checkExtension(properties, "VK_KHR_shader_clock");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderClockFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderClockFeaturesKHR));
		deviceShaderClockFeaturesKHR[ndx].sType = isShaderClockFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderClockFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderClockFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderClockFeaturesKHR)
		log << TestLog::Message << deviceShaderClockFeaturesKHR[0] << TestLog::EndMessage;

	if (isShaderClockFeaturesKHR &&
		(deviceShaderClockFeaturesKHR[0].shaderSubgroupClock != deviceShaderClockFeaturesKHR[1].shaderSubgroupClock ||
		 deviceShaderClockFeaturesKHR[0].shaderDeviceClock != deviceShaderClockFeaturesKHR[1].shaderDeviceClock))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderClockFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderDemoteToHelperInvocationFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures	deviceShaderDemoteToHelperInvocationFeatures[count];
	const bool												isShaderDemoteToHelperInvocationFeatures = checkExtension(properties, "VK_EXT_shader_demote_to_helper_invocation") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderDemoteToHelperInvocationFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures));
		deviceShaderDemoteToHelperInvocationFeatures[ndx].sType = isShaderDemoteToHelperInvocationFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderDemoteToHelperInvocationFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderDemoteToHelperInvocationFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderDemoteToHelperInvocationFeatures)
		log << TestLog::Message << deviceShaderDemoteToHelperInvocationFeatures[0] << TestLog::EndMessage;

	if (isShaderDemoteToHelperInvocationFeatures &&
		(deviceShaderDemoteToHelperInvocationFeatures[0].shaderDemoteToHelperInvocation != deviceShaderDemoteToHelperInvocationFeatures[1].shaderDemoteToHelperInvocation))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderDrawParametersFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderDrawParametersFeatures	deviceShaderDrawParametersFeatures[count];
	const bool										isShaderDrawParametersFeatures = context.contextSupports(vk::ApiVersion(1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderDrawParametersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderDrawParametersFeatures));
		deviceShaderDrawParametersFeatures[ndx].sType = isShaderDrawParametersFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderDrawParametersFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderDrawParametersFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderDrawParametersFeatures)
		log << TestLog::Message << deviceShaderDrawParametersFeatures[0] << TestLog::EndMessage;

	if (isShaderDrawParametersFeatures &&
		(deviceShaderDrawParametersFeatures[0].shaderDrawParameters != deviceShaderDrawParametersFeatures[1].shaderDrawParameters))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderDrawParametersFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderIntegerDotProductFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderIntegerDotProductFeatures	deviceShaderIntegerDotProductFeatures[count];
	const bool										isShaderIntegerDotProductFeatures = checkExtension(properties, "VK_KHR_shader_integer_dot_product") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderIntegerDotProductFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures));
		deviceShaderIntegerDotProductFeatures[ndx].sType = isShaderIntegerDotProductFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderIntegerDotProductFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderIntegerDotProductFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderIntegerDotProductFeatures)
		log << TestLog::Message << deviceShaderIntegerDotProductFeatures[0] << TestLog::EndMessage;

	if (isShaderIntegerDotProductFeatures &&
		(deviceShaderIntegerDotProductFeatures[0].shaderIntegerDotProduct != deviceShaderIntegerDotProductFeatures[1].shaderIntegerDotProduct))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderIntegerDotProductFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures	deviceShaderSubgroupExtendedTypesFeatures[count];
	const bool											isShaderSubgroupExtendedTypesFeatures = checkExtension(properties, "VK_KHR_shader_subgroup_extended_types") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderSubgroupExtendedTypesFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures));
		deviceShaderSubgroupExtendedTypesFeatures[ndx].sType = isShaderSubgroupExtendedTypesFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderSubgroupExtendedTypesFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderSubgroupExtendedTypesFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderSubgroupExtendedTypesFeatures)
		log << TestLog::Message << deviceShaderSubgroupExtendedTypesFeatures[0] << TestLog::EndMessage;

	if (isShaderSubgroupExtendedTypesFeatures &&
		(deviceShaderSubgroupExtendedTypesFeatures[0].shaderSubgroupExtendedTypes != deviceShaderSubgroupExtendedTypesFeatures[1].shaderSubgroupExtendedTypes))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderTerminateInvocationFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceShaderTerminateInvocationFeatures	deviceShaderTerminateInvocationFeatures[count];
	const bool											isShaderTerminateInvocationFeatures = checkExtension(properties, "VK_KHR_shader_terminate_invocation") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceShaderTerminateInvocationFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures));
		deviceShaderTerminateInvocationFeatures[ndx].sType = isShaderTerminateInvocationFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceShaderTerminateInvocationFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceShaderTerminateInvocationFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isShaderTerminateInvocationFeatures)
		log << TestLog::Message << deviceShaderTerminateInvocationFeatures[0] << TestLog::EndMessage;

	if (isShaderTerminateInvocationFeatures &&
		(deviceShaderTerminateInvocationFeatures[0].shaderTerminateInvocation != deviceShaderTerminateInvocationFeatures[1].shaderTerminateInvocation))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceShaderTerminateInvocationFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSubgroupSizeControlFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceSubgroupSizeControlFeatures	deviceSubgroupSizeControlFeatures[count];
	const bool									isSubgroupSizeControlFeatures = checkExtension(properties, "VK_EXT_subgroup_size_control") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceSubgroupSizeControlFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures));
		deviceSubgroupSizeControlFeatures[ndx].sType = isSubgroupSizeControlFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceSubgroupSizeControlFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceSubgroupSizeControlFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isSubgroupSizeControlFeatures)
		log << TestLog::Message << deviceSubgroupSizeControlFeatures[0] << TestLog::EndMessage;

	if (isSubgroupSizeControlFeatures &&
		(deviceSubgroupSizeControlFeatures[0].subgroupSizeControl != deviceSubgroupSizeControlFeatures[1].subgroupSizeControl ||
		 deviceSubgroupSizeControlFeatures[0].computeFullSubgroups != deviceSubgroupSizeControlFeatures[1].computeFullSubgroups))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceSubgroupSizeControlFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSynchronization2Features (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceSynchronization2Features	deviceSynchronization2Features[count];
	const bool									isSynchronization2Features = checkExtension(properties, "VK_KHR_synchronization2") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceSynchronization2Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSynchronization2Features));
		deviceSynchronization2Features[ndx].sType = isSynchronization2Features ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceSynchronization2Features[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceSynchronization2Features[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isSynchronization2Features)
		log << TestLog::Message << deviceSynchronization2Features[0] << TestLog::EndMessage;

	if (isSynchronization2Features &&
		(deviceSynchronization2Features[0].synchronization2 != deviceSynchronization2Features[1].synchronization2))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceSynchronization2Features");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT	deviceFragmentShaderInterlockFeaturesEXT[count];
	const bool											isFragmentShaderInterlockFeaturesEXT = checkExtension(properties, "VK_EXT_fragment_shader_interlock");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceFragmentShaderInterlockFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT));
		deviceFragmentShaderInterlockFeaturesEXT[ndx].sType = isFragmentShaderInterlockFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceFragmentShaderInterlockFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceFragmentShaderInterlockFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isFragmentShaderInterlockFeaturesEXT)
		log << TestLog::Message << deviceFragmentShaderInterlockFeaturesEXT[0] << TestLog::EndMessage;

	if (isFragmentShaderInterlockFeaturesEXT &&
		(deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderSampleInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderSampleInterlock ||
		 deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderPixelInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderPixelInterlock ||
		 deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderShadingRateInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderShadingRateInterlock))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT	deviceTexelBufferAlignmentFeaturesEXT[count];
	const bool										isTexelBufferAlignmentFeaturesEXT = checkExtension(properties, "VK_EXT_texel_buffer_alignment");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceTexelBufferAlignmentFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT));
		deviceTexelBufferAlignmentFeaturesEXT[ndx].sType = isTexelBufferAlignmentFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceTexelBufferAlignmentFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceTexelBufferAlignmentFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isTexelBufferAlignmentFeaturesEXT)
		log << TestLog::Message << deviceTexelBufferAlignmentFeaturesEXT[0] << TestLog::EndMessage;

	if (isTexelBufferAlignmentFeaturesEXT &&
		(deviceTexelBufferAlignmentFeaturesEXT[0].texelBufferAlignment != deviceTexelBufferAlignmentFeaturesEXT[1].texelBufferAlignment))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTextureCompressionASTCHDRFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceTextureCompressionASTCHDRFeatures	deviceTextureCompressionASTCHDRFeatures[count];
	const bool											isTextureCompressionASTCHDRFeatures = checkExtension(properties, "VK_EXT_texture_compression_astc_hdr") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceTextureCompressionASTCHDRFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures));
		deviceTextureCompressionASTCHDRFeatures[ndx].sType = isTextureCompressionASTCHDRFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceTextureCompressionASTCHDRFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceTextureCompressionASTCHDRFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isTextureCompressionASTCHDRFeatures)
		log << TestLog::Message << deviceTextureCompressionASTCHDRFeatures[0] << TestLog::EndMessage;

	if (isTextureCompressionASTCHDRFeatures &&
		(deviceTextureCompressionASTCHDRFeatures[0].textureCompressionASTC_HDR != deviceTextureCompressionASTCHDRFeatures[1].textureCompressionASTC_HDR))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceTextureCompressionASTCHDRFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTimelineSemaphoreFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceTimelineSemaphoreFeatures	deviceTimelineSemaphoreFeatures[count];
	const bool									isTimelineSemaphoreFeatures = checkExtension(properties, "VK_KHR_timeline_semaphore") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceTimelineSemaphoreFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures));
		deviceTimelineSemaphoreFeatures[ndx].sType = isTimelineSemaphoreFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceTimelineSemaphoreFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceTimelineSemaphoreFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isTimelineSemaphoreFeatures)
		log << TestLog::Message << deviceTimelineSemaphoreFeatures[0] << TestLog::EndMessage;

	if (isTimelineSemaphoreFeatures &&
		(deviceTimelineSemaphoreFeatures[0].timelineSemaphore != deviceTimelineSemaphoreFeatures[1].timelineSemaphore))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceTimelineSemaphoreFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTransformFeedbackFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceTransformFeedbackFeaturesEXT	deviceTransformFeedbackFeaturesEXT[count];
	const bool										isTransformFeedbackFeaturesEXT = checkExtension(properties, "VK_EXT_transform_feedback");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceTransformFeedbackFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT));
		deviceTransformFeedbackFeaturesEXT[ndx].sType = isTransformFeedbackFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceTransformFeedbackFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceTransformFeedbackFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isTransformFeedbackFeaturesEXT)
		log << TestLog::Message << deviceTransformFeedbackFeaturesEXT[0] << TestLog::EndMessage;

	if (isTransformFeedbackFeaturesEXT &&
		(deviceTransformFeedbackFeaturesEXT[0].transformFeedback != deviceTransformFeedbackFeaturesEXT[1].transformFeedback ||
		 deviceTransformFeedbackFeaturesEXT[0].geometryStreams != deviceTransformFeedbackFeaturesEXT[1].geometryStreams))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceTransformFeedbackFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceUniformBufferStandardLayoutFeatures	deviceUniformBufferStandardLayoutFeatures[count];
	const bool											isUniformBufferStandardLayoutFeatures = checkExtension(properties, "VK_KHR_uniform_buffer_standard_layout") || context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceUniformBufferStandardLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures));
		deviceUniformBufferStandardLayoutFeatures[ndx].sType = isUniformBufferStandardLayoutFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceUniformBufferStandardLayoutFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceUniformBufferStandardLayoutFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isUniformBufferStandardLayoutFeatures)
		log << TestLog::Message << deviceUniformBufferStandardLayoutFeatures[0] << TestLog::EndMessage;

	if (isUniformBufferStandardLayoutFeatures &&
		(deviceUniformBufferStandardLayoutFeatures[0].uniformBufferStandardLayout != deviceUniformBufferStandardLayoutFeatures[1].uniformBufferStandardLayout))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceUniformBufferStandardLayoutFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureWorkgroupMemoryExplicitLayoutFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR	deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[count];
	const bool													isWorkgroupMemoryExplicitLayoutFeaturesKHR = checkExtension(properties, "VK_KHR_workgroup_memory_explicit_layout");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR));
		deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[ndx].sType = isWorkgroupMemoryExplicitLayoutFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isWorkgroupMemoryExplicitLayoutFeaturesKHR)
		log << TestLog::Message << deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[0] << TestLog::EndMessage;

	if (isWorkgroupMemoryExplicitLayoutFeaturesKHR &&
		(deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[0].workgroupMemoryExplicitLayout != deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[1].workgroupMemoryExplicitLayout ||
		 deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[0].workgroupMemoryExplicitLayoutScalarBlockLayout != deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[1].workgroupMemoryExplicitLayoutScalarBlockLayout ||
		 deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[0].workgroupMemoryExplicitLayout8BitAccess != deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[1].workgroupMemoryExplicitLayout8BitAccess ||
		 deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[0].workgroupMemoryExplicitLayout16BitAccess != deviceWorkgroupMemoryExplicitLayoutFeaturesKHR[1].workgroupMemoryExplicitLayout16BitAccess))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVariablePointersFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceVariablePointersFeatures	deviceVariablePointersFeatures[count];
	const bool									isVariablePointersFeatures = checkExtension(properties, "VK_KHR_variable_pointers") || context.contextSupports(vk::ApiVersion(1, 1, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceVariablePointersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVariablePointersFeatures));
		deviceVariablePointersFeatures[ndx].sType = isVariablePointersFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceVariablePointersFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceVariablePointersFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isVariablePointersFeatures)
		log << TestLog::Message << deviceVariablePointersFeatures[0] << TestLog::EndMessage;

	if (isVariablePointersFeatures &&
		(deviceVariablePointersFeatures[0].variablePointersStorageBuffer != deviceVariablePointersFeatures[1].variablePointersStorageBuffer ||
		 deviceVariablePointersFeatures[0].variablePointers != deviceVariablePointersFeatures[1].variablePointers))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceVariablePointersFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexAttributeDivisorFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT	deviceVertexAttributeDivisorFeaturesEXT[count];
	const bool											isVertexAttributeDivisorFeaturesEXT = checkExtension(properties, "VK_EXT_vertex_attribute_divisor");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceVertexAttributeDivisorFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT));
		deviceVertexAttributeDivisorFeaturesEXT[ndx].sType = isVertexAttributeDivisorFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceVertexAttributeDivisorFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceVertexAttributeDivisorFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isVertexAttributeDivisorFeaturesEXT)
		log << TestLog::Message << deviceVertexAttributeDivisorFeaturesEXT[0] << TestLog::EndMessage;

	if (isVertexAttributeDivisorFeaturesEXT &&
		(deviceVertexAttributeDivisorFeaturesEXT[0].vertexAttributeInstanceRateDivisor != deviceVertexAttributeDivisorFeaturesEXT[1].vertexAttributeInstanceRateDivisor ||
		 deviceVertexAttributeDivisorFeaturesEXT[0].vertexAttributeInstanceRateZeroDivisor != deviceVertexAttributeDivisorFeaturesEXT[1].vertexAttributeInstanceRateZeroDivisor))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT	deviceVertexInputDynamicStateFeaturesEXT[count];
	const bool											isVertexInputDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_vertex_input_dynamic_state");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceVertexInputDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT));
		deviceVertexInputDynamicStateFeaturesEXT[ndx].sType = isVertexInputDynamicStateFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceVertexInputDynamicStateFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceVertexInputDynamicStateFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isVertexInputDynamicStateFeaturesEXT)
		log << TestLog::Message << deviceVertexInputDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

	if (isVertexInputDynamicStateFeaturesEXT &&
		(deviceVertexInputDynamicStateFeaturesEXT[0].vertexInputDynamicState != deviceVertexInputDynamicStateFeaturesEXT[1].vertexInputDynamicState))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkanMemoryModelFeaturesKHR (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceVulkanMemoryModelFeaturesKHR	deviceVulkanMemoryModelFeaturesKHR[count];
	const bool										isVulkanMemoryModelFeaturesKHR = context.contextSupports(vk::ApiVersion(1, 2, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceVulkanMemoryModelFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkanMemoryModelFeaturesKHR));
		deviceVulkanMemoryModelFeaturesKHR[ndx].sType = isVulkanMemoryModelFeaturesKHR ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceVulkanMemoryModelFeaturesKHR[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceVulkanMemoryModelFeaturesKHR[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isVulkanMemoryModelFeaturesKHR)
		log << TestLog::Message << deviceVulkanMemoryModelFeaturesKHR[0] << TestLog::EndMessage;

	if (isVulkanMemoryModelFeaturesKHR &&
		(deviceVulkanMemoryModelFeaturesKHR[0].vulkanMemoryModel != deviceVulkanMemoryModelFeaturesKHR[1].vulkanMemoryModel ||
		 deviceVulkanMemoryModelFeaturesKHR[0].vulkanMemoryModelDeviceScope != deviceVulkanMemoryModelFeaturesKHR[1].vulkanMemoryModelDeviceScope ||
		 deviceVulkanMemoryModelFeaturesKHR[0].vulkanMemoryModelAvailabilityVisibilityChains != deviceVulkanMemoryModelFeaturesKHR[1].vulkanMemoryModelAvailabilityVisibilityChains))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceVulkanMemoryModelFeaturesKHR");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceYcbcrImageArraysFeaturesEXT	deviceYcbcrImageArraysFeaturesEXT[count];
	const bool									isYcbcrImageArraysFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_image_arrays");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceYcbcrImageArraysFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT));
		deviceYcbcrImageArraysFeaturesEXT[ndx].sType = isYcbcrImageArraysFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceYcbcrImageArraysFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceYcbcrImageArraysFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isYcbcrImageArraysFeaturesEXT)
		log << TestLog::Message << deviceYcbcrImageArraysFeaturesEXT[0] << TestLog::EndMessage;

	if (isYcbcrImageArraysFeaturesEXT &&
		(deviceYcbcrImageArraysFeaturesEXT[0].ycbcrImageArrays != deviceYcbcrImageArraysFeaturesEXT[1].ycbcrImageArrays))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcrImageArraysFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT	deviceYcbcr2Plane444FormatsFeaturesEXT[count];
	const bool											isYcbcr2Plane444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_2plane_444_formats");

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceYcbcr2Plane444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT));
		deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].sType = isYcbcr2Plane444FormatsFeaturesEXT ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceYcbcr2Plane444FormatsFeaturesEXT[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isYcbcr2Plane444FormatsFeaturesEXT)
		log << TestLog::Message << deviceYcbcr2Plane444FormatsFeaturesEXT[0] << TestLog::EndMessage;

	if (isYcbcr2Plane444FormatsFeaturesEXT &&
		(deviceYcbcr2Plane444FormatsFeaturesEXT[0].ycbcr2plane444Formats != deviceYcbcr2Plane444FormatsFeaturesEXT[1].ycbcr2plane444Formats))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureZeroInitializeWorkgroupMemoryFeatures (Context& context)
{
	const VkPhysicalDevice		physicalDevice	= context.getPhysicalDevice();
	const CustomInstance		instance		(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
	const InstanceDriver&		vki				(instance.getDriver());
	const int					count			= 2u;
	TestLog&					log				= context.getTestContext().getLog();
	VkPhysicalDeviceFeatures2	extFeatures;
	vector<VkExtensionProperties> properties	= enumerateDeviceExtensionProperties(vki, physicalDevice, DE_NULL);

	VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures	deviceZeroInitializeWorkgroupMemoryFeatures[count];
	const bool												isZeroInitializeWorkgroupMemoryFeatures = checkExtension(properties, "VK_KHR_zero_initialize_workgroup_memory") || context.contextSupports(vk::ApiVersion(1, 3, 0));

	for (int ndx = 0; ndx < count; ++ndx)
	{
		deMemset(&deviceZeroInitializeWorkgroupMemoryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures));
		deviceZeroInitializeWorkgroupMemoryFeatures[ndx].sType = isZeroInitializeWorkgroupMemoryFeatures ? VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES : VK_STRUCTURE_TYPE_MAX_ENUM;
		deviceZeroInitializeWorkgroupMemoryFeatures[ndx].pNext = DE_NULL;

		deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
		extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
		extFeatures.pNext = &deviceZeroInitializeWorkgroupMemoryFeatures[ndx];

		vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
	}

	if (isZeroInitializeWorkgroupMemoryFeatures)
		log << TestLog::Message << deviceZeroInitializeWorkgroupMemoryFeatures[0] << TestLog::EndMessage;

	if (isZeroInitializeWorkgroupMemoryFeatures &&
		(deviceZeroInitializeWorkgroupMemoryFeatures[0].shaderZeroInitializeWorkgroupMemory != deviceZeroInitializeWorkgroupMemoryFeatures[1].shaderZeroInitializeWorkgroupMemory))
	{
		TCU_FAIL("Mismatch between VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures");
	}
	return tcu::TestStatus::pass("Querying succeeded");
}


void addSeparateFeatureTests (tcu::TestCaseGroup* testGroup)
{

	addFunctionCase(testGroup, "4444_formats_features_ext", "VkPhysicalDevice4444FormatsFeaturesEXT", testPhysicalDeviceFeature4444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "8_bit_storage_features", "VkPhysicalDevice8BitStorageFeatures", testPhysicalDeviceFeature8BitStorageFeatures);
	addFunctionCase(testGroup, "16_bit_storage_features", "VkPhysicalDevice16BitStorageFeatures", testPhysicalDeviceFeature16BitStorageFeatures);
	addFunctionCase(testGroup, "acceleration_structure_features_khr", "VkPhysicalDeviceAccelerationStructureFeaturesKHR", testPhysicalDeviceFeatureAccelerationStructureFeaturesKHR);
	addFunctionCase(testGroup, "astc_decode_features_ext", "VkPhysicalDeviceASTCDecodeFeaturesEXT", testPhysicalDeviceFeatureASTCDecodeFeaturesEXT);
	addFunctionCase(testGroup, "blend_operation_advanced_features_ext", "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT);
	addFunctionCase(testGroup, "buffer_device_address_features_ext", "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", testPhysicalDeviceFeatureBufferDeviceAddressFeaturesEXT);
	addFunctionCase(testGroup, "buffer_device_address_features", "VkPhysicalDeviceBufferDeviceAddressFeatures", testPhysicalDeviceFeatureBufferDeviceAddressFeatures);
	addFunctionCase(testGroup, "conditional_rendering_features_ext", "VkPhysicalDeviceConditionalRenderingFeaturesEXT", testPhysicalDeviceFeatureConditionalRenderingFeaturesEXT);
	addFunctionCase(testGroup, "custom_border_color_features_ext", "VkPhysicalDeviceCustomBorderColorFeaturesEXT", testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT);
	addFunctionCase(testGroup, "color_write_enable_features_ext", "VkPhysicalDeviceColorWriteEnableFeaturesEXT", testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT);
	addFunctionCase(testGroup, "descriptor_indexing_features", "VkPhysicalDeviceDescriptorIndexingFeatures", testPhysicalDeviceFeatureDescriptorIndexingFeatures);
	addFunctionCase(testGroup, "depth_clip_enable_features_ext", "VkPhysicalDeviceDepthClipEnableFeaturesEXT", testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT);
	addFunctionCase(testGroup, "dynamic_rendering_features", "VkPhysicalDeviceDynamicRenderingFeatures", testPhysicalDeviceFeatureDynamicRenderingFeatures);
	addFunctionCase(testGroup, "extended_dynamic_state_features_ext", "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT", testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state2_features_ext", "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT", testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT);
	addFunctionCase(testGroup, "fragment_density_map_features_ext", "VkPhysicalDeviceFragmentDensityMapFeaturesEXT", testPhysicalDeviceFeatureFragmentDensityMapFeaturesEXT);
	addFunctionCase(testGroup, "fragment_density_map2_features_ext", "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT", testPhysicalDeviceFeatureFragmentDensityMap2FeaturesEXT);
	addFunctionCase(testGroup, "fragment_shading_rate_features_khr", "VkPhysicalDeviceFragmentShadingRateFeaturesKHR", testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR);
	addFunctionCase(testGroup, "global_priority_query_features_khr", "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR", testPhysicalDeviceFeatureGlobalPriorityQueryFeaturesKHR);
	addFunctionCase(testGroup, "inline_uniform_block_features", "VkPhysicalDeviceInlineUniformBlockFeatures", testPhysicalDeviceFeatureInlineUniformBlockFeatures);
	addFunctionCase(testGroup, "index_type_uint8_features_ext", "VkPhysicalDeviceIndexTypeUint8FeaturesEXT", testPhysicalDeviceFeatureIndexTypeUint8FeaturesEXT);
	addFunctionCase(testGroup, "imageless_framebuffer_features", "VkPhysicalDeviceImagelessFramebufferFeatures", testPhysicalDeviceFeatureImagelessFramebufferFeatures);
	addFunctionCase(testGroup, "image_robustness_features", "VkPhysicalDeviceImageRobustnessFeatures", testPhysicalDeviceFeatureImageRobustnessFeatures);
	addFunctionCase(testGroup, "host_query_reset_features", "VkPhysicalDeviceHostQueryResetFeatures", testPhysicalDeviceFeatureHostQueryResetFeatures);
	addFunctionCase(testGroup, "line_rasterization_features_ext", "VkPhysicalDeviceLineRasterizationFeaturesEXT", testPhysicalDeviceFeatureLineRasterizationFeaturesEXT);
	addFunctionCase(testGroup, "maintenance4_features", "VkPhysicalDeviceMaintenance4Features", testPhysicalDeviceFeatureMaintenance4Features);
	addFunctionCase(testGroup, "multiview_features", "VkPhysicalDeviceMultiviewFeatures", testPhysicalDeviceFeatureMultiviewFeatures);
	addFunctionCase(testGroup, "multi_draw_features_ext", "VkPhysicalDeviceMultiDrawFeaturesEXT", testPhysicalDeviceFeatureMultiDrawFeaturesEXT);
	addFunctionCase(testGroup, "memory_priority_features_ext", "VkPhysicalDeviceMemoryPriorityFeaturesEXT", testPhysicalDeviceFeatureMemoryPriorityFeaturesEXT);
	addFunctionCase(testGroup, "device_memory_report_features_ext", "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT", testPhysicalDeviceFeatureDeviceMemoryReportFeaturesEXT);
	addFunctionCase(testGroup, "performance_query_features_khr", "VkPhysicalDevicePerformanceQueryFeaturesKHR", testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR);
	addFunctionCase(testGroup, "pipeline_creation_cache_control_features", "VkPhysicalDevicePipelineCreationCacheControlFeatures", testPhysicalDeviceFeaturePipelineCreationCacheControlFeatures);
	addFunctionCase(testGroup, "pipeline_executable_properties_features_khr", "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR", testPhysicalDeviceFeaturePipelineExecutablePropertiesFeaturesKHR);
	addFunctionCase(testGroup, "present_id_features_khr", "VkPhysicalDevicePresentIdFeaturesKHR", testPhysicalDeviceFeaturePresentIdFeaturesKHR);
	addFunctionCase(testGroup, "present_wait_features_khr", "VkPhysicalDevicePresentWaitFeaturesKHR", testPhysicalDeviceFeaturePresentWaitFeaturesKHR);
	addFunctionCase(testGroup, "protected_memory_features", "VkPhysicalDeviceProtectedMemoryFeatures", testPhysicalDeviceFeatureProtectedMemoryFeatures);
	addFunctionCase(testGroup, "provoking_vertex_features_ext", "VkPhysicalDeviceProvokingVertexFeaturesEXT", testPhysicalDeviceFeatureProvokingVertexFeaturesEXT);
	addFunctionCase(testGroup, "primitive_topology_list_restart_features_ext", "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT", testPhysicalDeviceFeaturePrimitiveTopologyListRestartFeaturesEXT);
	addFunctionCase(testGroup, "private_data_features", "VkPhysicalDevicePrivateDataFeatures", testPhysicalDeviceFeaturePrivateDataFeatures);
	addFunctionCase(testGroup, "ray_tracing_pipeline_features_khr", "VkPhysicalDeviceRayTracingPipelineFeaturesKHR", testPhysicalDeviceFeatureRayTracingPipelineFeaturesKHR);
	addFunctionCase(testGroup, "ray_query_features_khr", "VkPhysicalDeviceRayQueryFeaturesKHR", testPhysicalDeviceFeatureRayQueryFeaturesKHR);
	addFunctionCase(testGroup, "robustness2_features_ext", "VkPhysicalDeviceRobustness2FeaturesEXT", testPhysicalDeviceFeatureRobustness2FeaturesEXT);
	addFunctionCase(testGroup, "sampler_ycbcr_conversion_features", "VkPhysicalDeviceSamplerYcbcrConversionFeatures", testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures);
	addFunctionCase(testGroup, "scalar_block_layout_features", "VkPhysicalDeviceScalarBlockLayoutFeatures", testPhysicalDeviceFeatureScalarBlockLayoutFeatures);
	addFunctionCase(testGroup, "separate_depth_stencil_layouts_features", "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures", testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures);
	addFunctionCase(testGroup, "shader_atomic_int64_features", "VkPhysicalDeviceShaderAtomicInt64Features", testPhysicalDeviceFeatureShaderAtomicInt64Features);
	addFunctionCase(testGroup, "shader_atomic_float_features_ext", "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT", testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT);
	addFunctionCase(testGroup, "shader_atomic_float2_features_ext", "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT", testPhysicalDeviceFeatureShaderAtomicFloat2FeaturesEXT);
	addFunctionCase(testGroup, "shader_float16_int8_features", "VkPhysicalDeviceShaderFloat16Int8Features", testPhysicalDeviceFeatureShaderFloat16Int8Features);
	addFunctionCase(testGroup, "shader_clock_features_khr", "VkPhysicalDeviceShaderClockFeaturesKHR", testPhysicalDeviceFeatureShaderClockFeaturesKHR);
	addFunctionCase(testGroup, "shader_demote_to_helper_invocation_features", "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures", testPhysicalDeviceFeatureShaderDemoteToHelperInvocationFeatures);
	addFunctionCase(testGroup, "shader_draw_parameters_features", "VkPhysicalDeviceShaderDrawParametersFeatures", testPhysicalDeviceFeatureShaderDrawParametersFeatures);
	addFunctionCase(testGroup, "shader_integer_dot_product_features", "VkPhysicalDeviceShaderIntegerDotProductFeatures", testPhysicalDeviceFeatureShaderIntegerDotProductFeatures);
	addFunctionCase(testGroup, "shader_subgroup_extended_types_features", "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures", testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures);
	addFunctionCase(testGroup, "shader_terminate_invocation_features", "VkPhysicalDeviceShaderTerminateInvocationFeatures", testPhysicalDeviceFeatureShaderTerminateInvocationFeatures);
	addFunctionCase(testGroup, "subgroup_size_control_features", "VkPhysicalDeviceSubgroupSizeControlFeatures", testPhysicalDeviceFeatureSubgroupSizeControlFeatures);
	addFunctionCase(testGroup, "synchronization2_features", "VkPhysicalDeviceSynchronization2Features", testPhysicalDeviceFeatureSynchronization2Features);
	addFunctionCase(testGroup, "fragment_shader_interlock_features_ext", "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT);
	addFunctionCase(testGroup, "texel_buffer_alignment_features_ext", "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT);
	addFunctionCase(testGroup, "texture_compression_astchdr_features", "VkPhysicalDeviceTextureCompressionASTCHDRFeatures", testPhysicalDeviceFeatureTextureCompressionASTCHDRFeatures);
	addFunctionCase(testGroup, "timeline_semaphore_features", "VkPhysicalDeviceTimelineSemaphoreFeatures", testPhysicalDeviceFeatureTimelineSemaphoreFeatures);
	addFunctionCase(testGroup, "transform_feedback_features_ext", "VkPhysicalDeviceTransformFeedbackFeaturesEXT", testPhysicalDeviceFeatureTransformFeedbackFeaturesEXT);
	addFunctionCase(testGroup, "uniform_buffer_standard_layout_features", "VkPhysicalDeviceUniformBufferStandardLayoutFeatures", testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures);
	addFunctionCase(testGroup, "workgroup_memory_explicit_layout_features_khr", "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR", testPhysicalDeviceFeatureWorkgroupMemoryExplicitLayoutFeaturesKHR);
	addFunctionCase(testGroup, "variable_pointers_features", "VkPhysicalDeviceVariablePointersFeatures", testPhysicalDeviceFeatureVariablePointersFeatures);
	addFunctionCase(testGroup, "vertex_attribute_divisor_features_ext", "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT", testPhysicalDeviceFeatureVertexAttributeDivisorFeaturesEXT);
	addFunctionCase(testGroup, "vertex_input_dynamic_state_features_ext", "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT", testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "vulkan_memory_model_features_khr", "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR", testPhysicalDeviceFeatureVulkanMemoryModelFeaturesKHR);
	addFunctionCase(testGroup, "ycbcr_image_arrays_features_ext", "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT);
	addFunctionCase(testGroup, "ycbcr2_plane444_formats_features_ext", "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT", testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "zero_initialize_workgroup_memory_features", "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures", testPhysicalDeviceFeatureZeroInitializeWorkgroupMemoryFeatures);
}

