/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2021_0963;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeNoException;
import static org.junit.Assume.assumeTrue;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.os.Bundle;
import android.os.RemoteCallback;
import android.provider.Settings;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.By;
import androidx.test.uiautomator.UiDevice;
import androidx.test.uiautomator.Until;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {
    private DevicePolicyManager mDevicePolicyManager;
    private ComponentName mComponentName;
    private Context mContext;
    private UiDevice mDevice;
    private Resources mResources;

    private byte[] getByteArrayFromRawRes(int resId, String resName) throws IOException {
        byte[] byteArray = null;
        try (InputStream inStream = mResources.openRawResource(resId);
                ByteArrayOutputStream outStream = new ByteArrayOutputStream(); ) {
            assumeTrue(mContext.getString(R.string.rawResOpenError, resName), inStream != null);
            byteArray = new byte[1024];
            int nRead = inStream.read(byteArray, 0, byteArray.length);
            assumeTrue(mContext.getString(R.string.streamReadError, resName), nRead > 0);
            outStream.write(byteArray, 0, nRead);
        }
        return byteArray;
    }

    @After
    public void tearDown() {
        try {
            // Go to home screen
            mDevice.executeShellCommand(mContext.getString(R.string.cmdAdbHome));

            // Remove key pair added by the test as part of cleanup
            mDevicePolicyManager.removeKeyPair(mComponentName, mContext.getString(R.string.alias));
        } catch (Exception e) {
            // ignore all exceptions as the test is already complete
        }
    }

    @Test
    public void testOverlayButtonPresence() {
        try {
            // Create the byte arrays from raw resources of private key and user certificate
            // respectively.
            mContext = getInstrumentation().getContext();
            mResources = mContext.getResources();
            byte[] privateKeyByteArray =
                    getByteArrayFromRawRes(
                            R.raw.cve_2021_0963_pkey, mContext.getString(R.string.pKey));
            byte[] userCertByteArray =
                    getByteArrayFromRawRes(
                            R.raw.cve_2021_0963_usercert, mContext.getString(R.string.userCert));

            // Install key pair required to launch KeyChainActivity dialog
            KeyFactory kf = KeyFactory.getInstance(mContext.getString(R.string.typeKey));
            PrivateKey privKey = kf.generatePrivate(new PKCS8EncodedKeySpec(privateKeyByteArray));
            CertificateFactory cf =
                    CertificateFactory.getInstance(mContext.getString(R.string.typeCert));
            Certificate cert = cf.generateCertificate(new ByteArrayInputStream(userCertByteArray));
            mDevicePolicyManager = mContext.getSystemService(DevicePolicyManager.class);
            mComponentName =
                    new ComponentName(
                            PocDeviceAdminReceiver.class.getPackage().getName(),
                            PocDeviceAdminReceiver.class.getName());
            assumeTrue(
                    mDevicePolicyManager.installKeyPair(
                            mComponentName, privKey, cert, mContext.getString(R.string.alias)));

            // Start the overlay service
            Intent intent = new Intent(mContext, PocService.class);
            assumeTrue(
                    mContext.getString(R.string.exceptionCanNotDrawOverlays),
                    Settings.canDrawOverlays(mContext));
            CompletableFuture<PocStatus> callbackReturn = new CompletableFuture<>();
            RemoteCallback cb =
                    new RemoteCallback(
                            (Bundle result) -> {
                                PocStatus pocStatus =
                                        new PocStatus(
                                                result.getInt(mContext.getString(R.string.status)),
                                                result.getString(
                                                        mContext.getString(R.string.message)));
                                callbackReturn.complete(pocStatus);
                            });
            intent.putExtra(mContext.getString(R.string.callback), cb);
            mContext.startService(intent);
            PocStatus result =
                    callbackReturn.get(
                            mResources.getInteger(R.integer.timeoutMs), TimeUnit.MILLISECONDS);
            assumeTrue(
                    result.getErrorMessage(),
                    result.getStatusCode() != mResources.getInteger(R.integer.assumptionFailure));

            // Wait for the overlay window
            mDevice = UiDevice.getInstance(getInstrumentation());
            Pattern overlayTextPattern =
                    Pattern.compile(
                            mContext.getString(R.string.txtOverlayBtn), Pattern.CASE_INSENSITIVE);
            assumeTrue(
                    mContext.getString(R.string.exceptionOverlayUiNotVisible),
                    mDevice.wait(
                            Until.hasObject(By.text(overlayTextPattern)),
                            mResources.getInteger(R.integer.timeoutMs)));

            // Start PocActivity which in turn starts the vulnerable activity
            intent = new Intent(mContext, PocActivity.class);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
            CompletableFuture<PocStatus> pocActivityReturn = new CompletableFuture<>();
            RemoteCallback pocActivityCb =
                    new RemoteCallback(
                            (Bundle pocActivityResult) -> {
                                PocStatus pocStatus =
                                        new PocStatus(
                                                pocActivityResult.getInt(
                                                        mContext.getString(R.string.status)),
                                                pocActivityResult.getString(
                                                        mContext.getString(R.string.message)));
                                pocActivityReturn.complete(pocStatus);
                            });
            intent.putExtra(mContext.getString(R.string.callback), pocActivityCb);
            mContext.startActivity(intent);
            result =
                    pocActivityReturn.get(
                            mResources.getInteger(R.integer.timeoutMs), TimeUnit.MILLISECONDS);
            assumeTrue(
                    result.getErrorMessage(),
                    result.getStatusCode() != mResources.getInteger(R.integer.assumptionFailure));

            // Get the vulnerable activity name by using an alternative intent
            Intent vulIntent = new Intent(mContext.getString(R.string.action));
            ResolveInfo ri =
                    mContext.getPackageManager()
                            .resolveActivity(vulIntent, PackageManager.MATCH_DEFAULT_ONLY);
            String vulnerableActivityName = ri.activityInfo.name;
            String vulnerablePkgName = ri.activityInfo.packageName;

            // Wait until the object of launcher activity is gone
            boolean overlayDisallowed =
                    mDevice.wait(
                            Until.gone(By.pkg(mContext.getPackageName())),
                            mResources.getInteger(R.integer.timeoutMs));

            // Check if the currently resumed activity is the vulnerable activity
            String activityDump =
                    mDevice.executeShellCommand(
                            mContext.getString(
                                    R.string.cmdDumpsysActivityByActivity, vulnerableActivityName));
            Pattern activityPattern =
                    Pattern.compile(
                            mContext.getString(R.string.flagActivityResumed),
                            Pattern.CASE_INSENSITIVE);
            assumeTrue(
                    mContext.getString(
                            R.string.exceptionVulActivityNotResume, vulnerableActivityName),
                    activityPattern.matcher(activityDump).find());

            // Check if vulnerable activity's UI is visible
            String vulPkgDump =
                    mDevice.executeShellCommand(
                            mContext.getString(
                                    R.string.cmdDumpsysActivityByPkg, vulnerablePkgName));
            boolean isVisible = false;
            for (String vulPkgDumpElement :
                    vulPkgDump.split(mContext.getString(R.string.strSplitRegex))) {
                if (vulPkgDumpElement
                        .toLowerCase()
                        .contains(vulnerableActivityName.toLowerCase())) {
                    if (vulPkgDumpElement.contains(
                            mContext.getString(R.string.flagActivityVisible))) {
                        isVisible = true;
                        break;
                    }
                }
            }
            assumeTrue(
                    mContext.getString(R.string.exceptionVulUiNotVisible, vulnerableActivityName),
                    isVisible);

            // On vulnerable device, vulnerable activity will be overlaid so 'overlayDisallowed'
            // will be set to true so the test fails, else it passes.
            assertTrue(
                    mContext.getString(R.string.failMsg, vulnerableActivityName),
                    overlayDisallowed);
        } catch (Exception e) {
            assumeNoException(e);
        }
    }
}
