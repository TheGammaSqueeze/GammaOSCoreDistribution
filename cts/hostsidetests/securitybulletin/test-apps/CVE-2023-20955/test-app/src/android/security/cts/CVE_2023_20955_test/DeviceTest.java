/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_20955_test;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertFalse;
import static org.junit.Assume.assumeNoException;
import static org.junit.Assume.assumeTrue;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.UserManager;
import android.provider.Settings;
import android.widget.ImageButton;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.By;
import androidx.test.uiautomator.BySelector;
import androidx.test.uiautomator.UiDevice;
import androidx.test.uiautomator.Until;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.regex.Pattern;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {
    private static final int TIMEOUT_MS = 5000;
    private Context mContext;
    private UiDevice mDevice;

    private void waitAndClick(BySelector selector) {
        assumeTrue(mContext.getString(R.string.msgNotFoundTxt, selector.toString()),
                mDevice.wait(Until.hasObject(selector), TIMEOUT_MS));
        mDevice.findObject(selector).click();
    }

    @Test
    public void testAppInfoUninstallForAllUsersDisabled() {
        try {
            mContext = getInstrumentation().getTargetContext();
            mDevice = UiDevice.getInstance(getInstrumentation());

            // Restrict current user to disallow controlling apps
            ComponentName deviceAdminComponent =
                    new ComponentName(mContext, PocDeviceAdminReceiver.class);
            DevicePolicyManager policyManager = null;
            policyManager = mContext.getSystemService(DevicePolicyManager.class);
            policyManager.addUserRestriction(deviceAdminComponent,
                    UserManager.DISALLOW_APPS_CONTROL);

            // Waiting for user restriction to be added
            boolean disallowAppsControlVal =
                    (boolean) policyManager.getUserRestrictions(deviceAdminComponent)
                            .getBoolean(UserManager.DISALLOW_APPS_CONTROL);
            while (!disallowAppsControlVal && System.currentTimeMillis() < TIMEOUT_MS) {
                disallowAppsControlVal = policyManager.getUserRestrictions(deviceAdminComponent)
                        .getBoolean(UserManager.DISALLOW_APPS_CONTROL);
                Thread.sleep(100);
            }
            assumeTrue(mContext.getString(R.string.msgSetUserRestrictionFailed),
                    disallowAppsControlVal);

            // Launching "application info" window for test helper app
            Uri pkgUri = Uri.fromParts(mContext.getString(R.string.uriScheme),
                    mContext.getString(R.string.pkgNameHelper), null);
            Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS, pkgUri);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
            mContext.startActivity(intent);

            // Wait for the application info window and click on 3 dots with:
            // content description = "More options"
            Pattern descPattern = Pattern.compile(mContext.getString(R.string.patternMoreOptions),
                    Pattern.CASE_INSENSITIVE);
            waitAndClick(By.clazz(ImageButton.class).desc(descPattern));

            // Wait for a menu to appear. When it appears, click on the text "Uninstall for all
            // users".
            Pattern textPattern =
                    Pattern.compile(mContext.getString(R.string.patternUninstallAllUsers),
                            Pattern.CASE_INSENSITIVE);
            waitAndClick(By.text(textPattern));

            // Retrieve the package name of installer app
            Intent packageInstallerIntent = new Intent(Intent.ACTION_DELETE, pkgUri);
            ComponentName componentName =
                    packageInstallerIntent.resolveActivity(mContext.getPackageManager());
            String pkgNameInstaller = mContext.getString(R.string.pkgNameInstaller);
            if (componentName != null && componentName.getPackageName() != null) {
                pkgNameInstaller = componentName.getPackageName();
            }

            // Wait for UI with package = "com.android.packageinstaller" (AOSP), text containing
            // "uninstall". If found, it indicates vulnerable behaviour and anyone can uninstall
            // app for all users despite the user restrictions.
            textPattern = Pattern.compile(mContext.getString(R.string.patternUninstall),
                    Pattern.CASE_INSENSITIVE);
            assertFalse(mContext.getString(R.string.failMsg), mDevice
                    .wait(Until.hasObject(By.pkg(pkgNameInstaller).text(textPattern)), TIMEOUT_MS));
        } catch (Exception e) {
            assumeNoException(e);
        } finally {
            try {
                // Go to the home screen
                mDevice.pressHome();
            } catch (Exception e) {
                // ignore
            }
        }
    }
}
