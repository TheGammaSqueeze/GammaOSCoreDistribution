/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2022_20138;

import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
import static org.junit.Assert.assertNull;
import static org.junit.Assume.assumeNoException;
import static org.junit.Assume.assumeNotNull;
import static org.junit.Assume.assumeTrue;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;

import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {

    @Test
    public void testCVE_2022_20138() {
        try {
            Context context = getApplicationContext();
            Resources resources = context.getResources();
            BlockingQueue<Boolean> blockingQueue =
                    new ArrayBlockingQueue<>(resources.getInteger(R.integer.queueSize));

            // Register a shared preferences listener to listen to any update made by PocReceiver
            // to shared preferences.
            SharedPreferences sharedPrefs = context.getSharedPreferences(
                    context.getString(R.string.sharedPreferences), Context.MODE_APPEND);
            OnSharedPreferenceChangeListener listener = new OnSharedPreferenceChangeListener() {
                @Override
                public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
                        String key) {
                    if (key.equals(context.getString(R.string.resultKey))) {
                        blockingQueue.add(true);
                    }
                }
            };
            sharedPrefs.registerOnSharedPreferenceChangeListener(listener);

            // Send a broadcast using intent action
            // DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED. This is allowed for our
            // unprivileged app if vulnerability is active.
            Intent intent = new Intent(DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            intent.putExtra(Intent.EXTRA_USER, resources.getInteger(R.integer.userId));

            PackageManager packageManager = context.getPackageManager();
            List<ResolveInfo> infos = packageManager.queryBroadcastReceivers(intent, 0);
            assumeTrue(context.getString(R.string.receiverNotFound, intent), !infos.isEmpty());
            String activityName = null;
            for (ResolveInfo info : infos) {
                if (info != null && info.activityInfo != null
                        && info.activityInfo.packageName != null) {
                    if (info.activityInfo.packageName.equals(context.getPackageName())) {
                        activityName = info.activityInfo.name;
                    }
                }
            }
            assumeNotNull(context.getString(R.string.failQueryReceivers), activityName);
            intent.setComponent(new ComponentName(context.getPackageName(), activityName));

            context.sendBroadcast(intent);

            // Wait on a result from PocReceiver
            Boolean intentReceived = null;
            intentReceived = blockingQueue.poll(resources.getInteger(R.integer.timeoutMs),
                    TimeUnit.MILLISECONDS);

            // If 'intentReceived' is non-null i.e. intent was received by the broadcast receiver,
            // it means broadcast is sent without any restrictions, which indicates that
            // vulnerability
            // is active.
            assertNull(context.getString(R.string.failMessage), intentReceived);
        } catch (Exception e) {
            if (e instanceof SecurityException && e.getMessage() != null && e.getMessage().trim()
                    .contains(DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED)) {
                return;
            }
            assumeNoException(e);
        }
    }
}
