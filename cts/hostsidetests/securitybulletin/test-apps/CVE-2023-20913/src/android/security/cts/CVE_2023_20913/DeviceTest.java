/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_20913;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeNoException;
import static org.junit.Assume.assumeTrue;

import android.app.KeyguardManager;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.os.PowerManager;
import android.os.UserHandle;
import android.provider.Settings;
import android.telecom.TelecomManager;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.By;
import androidx.test.uiautomator.UiDevice;
import androidx.test.uiautomator.Until;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {
    private Context mContext = null;
    private List<String> mViolations;
    private List<String> mVulnerabilities;
    PackageManager mPackageManager = null;

    private String getTelephonyPackageName() {
        UiAutomation ui = getInstrumentation().getUiAutomation();
        String name = mContext.getString(R.string.pkgDefaultTelephony);
        try {
            ui.adoptShellPermissionIdentity(android.Manifest.permission.INTERACT_ACROSS_USERS);
            Intent intent = new Intent(TelecomManager.ACTION_CHANGE_PHONE_ACCOUNTS);
            ResolveInfo info =
                    mPackageManager.resolveActivityAsUser(
                            intent, PackageManager.MATCH_SYSTEM_ONLY, UserHandle.USER_SYSTEM);
            name = info.activityInfo.packageName;
        } catch (Exception e) {
            assumeNoException(e);
        } finally {
            ui.dropShellPermissionIdentity();
        }
        return name;
    }

    public void testActivity(String cls) throws Exception {
        UiDevice device = null;
        try {
            mPackageManager = mContext.getPackageManager();
            device = UiDevice.getInstance(getInstrumentation());

            // Start the overlay service
            Intent serviceIntent = new Intent(mContext, PocService.class);
            assumeTrue(
                    mContext.getString(R.string.msgCannotDrawOverlays),
                    Settings.canDrawOverlays(mContext));
            mContext.startService(serviceIntent);

            // Wait for the overlay window
            Pattern overlayTextPattern =
                    Pattern.compile(
                            mContext.getString(R.string.textOverlayButton),
                            Pattern.CASE_INSENSITIVE);
            final long launchTimeoutMs = 20_000L;

            if (!device.wait(Until.hasObject(By.text(overlayTextPattern)), launchTimeoutMs)) {
                mViolations.add(cls + mContext.getString(R.string.overlayUiScreenError));
                return;
            }

            // Start the vulnerable activity
            String pkg = getTelephonyPackageName();
            Intent intent = new Intent();
            String vulActivity = pkg + cls;
            intent.setClassName(pkg, vulActivity);
            ResolveInfo ri =
                    mPackageManager.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
            if (ri == null) {
                mViolations.add(cls + mContext.getString(R.string.msgActivityNotFound, intent));
                return;
            }
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
            mContext.startActivity(intent);

            // Wait until overlay window is gone
            boolean overlayDisallowed =
                    device.wait(Until.gone(By.text(overlayTextPattern)), launchTimeoutMs);

            // Check if the currently running activity is the vulnerable activity
            String activityDump =
                    device.executeShellCommand(
                            mContext.getString(R.string.dumpsysActivityCmd, vulActivity));
            Pattern activityPattern =
                    Pattern.compile(
                            mContext.getString(R.string.mResumedTrue), Pattern.CASE_INSENSITIVE);
            if (!(activityPattern.matcher(activityDump).find())) {
                mViolations.add(
                        cls + mContext.getString(R.string.vulActivityNotRunningError, vulActivity));
                return;
            }

            // If overlayDisallowed is not true then add the class name to mVulnerabilities
            if (!overlayDisallowed) {
                mVulnerabilities.add(cls);
            }
        } catch (Exception e) {
            mViolations.add(e.getMessage());
        } finally {
            try {
                // To exit current activity so that new activity starts
                device.pressHome();
            } catch (Exception e) {
                // Ignoring exceptions here since any exception caught here is unrelated to test
            }
        }
    }

    @Test
    public void testOverlayButtonPresence() {
        try {
            mContext = getInstrumentation().getTargetContext();
            KeyguardManager keyguardManager = mContext.getSystemService(KeyguardManager.class);
            PowerManager powerManager = mContext.getSystemService(PowerManager.class);
            assumeTrue(
                    mContext.getString(R.string.msgDeviceLocked),
                    powerManager.isInteractive() && !keyguardManager.isKeyguardLocked());
            mViolations = new ArrayList<String>();
            mVulnerabilities = new ArrayList<String>();
            testActivity(mContext.getString(R.string.activityAccessibilitySettings));
            testActivity(mContext.getString(R.string.activityPhoneAccountSettings));
            testActivity(mContext.getString(R.string.activityVoicemailSettings));
            if (mVulnerabilities.isEmpty()) {
                assumeTrue(
                        mContext.getString(R.string.msgAssumptionFailure) + mViolations,
                        mViolations.isEmpty());
            } else {
                fail(mContext.getString(R.string.msgOverlayError) + mVulnerabilities);
            }
        } catch (Exception e) {
            assumeNoException(e);
        }
    }
}
