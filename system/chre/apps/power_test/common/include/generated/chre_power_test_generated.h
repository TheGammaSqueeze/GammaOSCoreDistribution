// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_
#define FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_

#include "flatbuffers/flatbuffers.h"

namespace chre {
namespace power_test {

struct TimerMessage;
struct TimerMessageBuilder;

struct WifiScanMessage;
struct WifiScanMessageBuilder;

struct GnssLocationMessage;
struct GnssLocationMessageBuilder;

struct CellQueryMessage;
struct CellQueryMessageBuilder;

struct AudioRequestMessage;
struct AudioRequestMessageBuilder;

struct SensorRequestMessage;
struct SensorRequestMessageBuilder;

struct BreakItMessage;
struct BreakItMessageBuilder;

struct NanoappResponseMessage;
struct NanoappResponseMessageBuilder;

struct GnssMeasurementMessage;
struct GnssMeasurementMessageBuilder;

struct WifiNanSubMessage;
struct WifiNanSubMessageBuilder;

struct WifiNanSubCancelMessage;
struct WifiNanSubCancelMessageBuilder;

struct WifiNanSubResponseMessage;
struct WifiNanSubResponseMessageBuilder;

/// Indicates which of the following messages is being sent to / from the
/// nanoapp. Use uint as the base type to match the message type in
/// chreMessageFromHostData.
enum class MessageType : uint32_t {
  UNSPECIFIED = 0,
  /// Should be used with TimerMessage
  TIMER_TEST = 1,
  /// Should be used with WifiScanMessage
  WIFI_SCAN_TEST = 2,
  /// Should be used with GnssLocationMessage
  GNSS_LOCATION_TEST = 3,
  /// Should be used with CellQueryMessage
  CELL_QUERY_TEST = 4,
  /// Should be used with AudioRequestMessage
  AUDIO_REQUEST_TEST = 5,
  /// Should be used with SensorRequestMessage
  SENSOR_REQUEST_TEST = 6,
  /// Should be used with BreakItMessage
  BREAK_IT_TEST = 7,
  /// Should be used with NanoappResponseMessage
  NANOAPP_RESPONSE = 8,
  /// Should be used with GnssMeasurementMessage
  GNSS_MEASUREMENT_TEST = 9,
  /// Should be used with WifiNanSubMessage
  WIFI_NAN_SUB = 10,
  /// Should be used with WifiNanSubCancelMessage
  WIFI_NAN_SUB_CANCEL = 11,
  /// Should be used with WifiNanSubResponseMessage
  WIFI_NAN_SUB_RESP = 12,
  MIN = UNSPECIFIED,
  MAX = WIFI_NAN_SUB_RESP
};

inline const MessageType (&EnumValuesMessageType())[13] {
  static const MessageType values[] = {
    MessageType::UNSPECIFIED,
    MessageType::TIMER_TEST,
    MessageType::WIFI_SCAN_TEST,
    MessageType::GNSS_LOCATION_TEST,
    MessageType::CELL_QUERY_TEST,
    MessageType::AUDIO_REQUEST_TEST,
    MessageType::SENSOR_REQUEST_TEST,
    MessageType::BREAK_IT_TEST,
    MessageType::NANOAPP_RESPONSE,
    MessageType::GNSS_MEASUREMENT_TEST,
    MessageType::WIFI_NAN_SUB,
    MessageType::WIFI_NAN_SUB_CANCEL,
    MessageType::WIFI_NAN_SUB_RESP
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[14] = {
    "UNSPECIFIED",
    "TIMER_TEST",
    "WIFI_SCAN_TEST",
    "GNSS_LOCATION_TEST",
    "CELL_QUERY_TEST",
    "AUDIO_REQUEST_TEST",
    "SENSOR_REQUEST_TEST",
    "BREAK_IT_TEST",
    "NANOAPP_RESPONSE",
    "GNSS_MEASUREMENT_TEST",
    "WIFI_NAN_SUB",
    "WIFI_NAN_SUB_CANCEL",
    "WIFI_NAN_SUB_RESP",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType::UNSPECIFIED, MessageType::WIFI_NAN_SUB_RESP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

/// All the various WiFi scan types that can be interacted with inside the
/// nanoapp. The values used here map directly to values from the CHRE API.
enum class WifiScanType : uint8_t {
  ACTIVE = 0,
  ACTIVE_PLUS_PASSIVE_DFS = 1,
  PASSIVE = 2,
  NO_PREFERENCE = 3,
  MIN = ACTIVE,
  MAX = NO_PREFERENCE
};

inline const WifiScanType (&EnumValuesWifiScanType())[4] {
  static const WifiScanType values[] = {
    WifiScanType::ACTIVE,
    WifiScanType::ACTIVE_PLUS_PASSIVE_DFS,
    WifiScanType::PASSIVE,
    WifiScanType::NO_PREFERENCE
  };
  return values;
}

inline const char * const *EnumNamesWifiScanType() {
  static const char * const names[5] = {
    "ACTIVE",
    "ACTIVE_PLUS_PASSIVE_DFS",
    "PASSIVE",
    "NO_PREFERENCE",
    nullptr
  };
  return names;
}

inline const char *EnumNameWifiScanType(WifiScanType e) {
  if (flatbuffers::IsOutRange(e, WifiScanType::ACTIVE, WifiScanType::NO_PREFERENCE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWifiScanType()[index];
}

/// All the various WiFi radio chain preferences that can be interacted with
/// inside the nanoapp. The values used here map directly to values from the
/// CHRE API.
enum class WifiRadioChain : uint8_t {
  DEFAULT = 0,
  LOW_LATENCY = 1,
  LOW_POWER = 2,
  HIGH_ACCURACY = 3,
  MIN = DEFAULT,
  MAX = HIGH_ACCURACY
};

inline const WifiRadioChain (&EnumValuesWifiRadioChain())[4] {
  static const WifiRadioChain values[] = {
    WifiRadioChain::DEFAULT,
    WifiRadioChain::LOW_LATENCY,
    WifiRadioChain::LOW_POWER,
    WifiRadioChain::HIGH_ACCURACY
  };
  return values;
}

inline const char * const *EnumNamesWifiRadioChain() {
  static const char * const names[5] = {
    "DEFAULT",
    "LOW_LATENCY",
    "LOW_POWER",
    "HIGH_ACCURACY",
    nullptr
  };
  return names;
}

inline const char *EnumNameWifiRadioChain(WifiRadioChain e) {
  if (flatbuffers::IsOutRange(e, WifiRadioChain::DEFAULT, WifiRadioChain::HIGH_ACCURACY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWifiRadioChain()[index];
}

/// All the various WiFi channel sets that can be interacted with inside the
/// nanoapp. The values used here map directly to values from the CHRE API.
enum class WifiChannelSet : uint8_t {
  NON_DFS = 0,
  ALL = 1,
  MIN = NON_DFS,
  MAX = ALL
};

inline const WifiChannelSet (&EnumValuesWifiChannelSet())[2] {
  static const WifiChannelSet values[] = {
    WifiChannelSet::NON_DFS,
    WifiChannelSet::ALL
  };
  return values;
}

inline const char * const *EnumNamesWifiChannelSet() {
  static const char * const names[3] = {
    "NON_DFS",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameWifiChannelSet(WifiChannelSet e) {
  if (flatbuffers::IsOutRange(e, WifiChannelSet::NON_DFS, WifiChannelSet::ALL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWifiChannelSet()[index];
}

/// All the various sensors that can be interacted with inside the nanoapp.
/// The values used here map directly to values from the CHRE API
enum class SensorType : uint8_t {
  UNKNOWN = 0,
  ACCELEROMETER = 1,
  INSTANT_MOTION_DETECT = 2,
  STATIONARY_DETECT = 3,
  GYROSCOPE = 6,
  UNCALIBRATED_GYROSCOPE = 7,
  GEOMAGNETIC_FIELD = 8,
  UNCALIBRATED_GEOMAGNETIC_FIELD = 9,
  PRESSURE = 10,
  LIGHT = 12,
  PROXIMITY = 13,
  STEP_DETECT = 23,
  STEP_COUNTER = 24,
  UNCALIBRATED_ACCELEROMETER = 55,
  ACCELEROMETER_TEMPERATURE = 56,
  GYROSCOPE_TEMPERATURE = 57,
  GEOMAGNETIC_FIELD_TEMPERATURE = 58,
  MIN = UNKNOWN,
  MAX = GEOMAGNETIC_FIELD_TEMPERATURE
};

inline const SensorType (&EnumValuesSensorType())[17] {
  static const SensorType values[] = {
    SensorType::UNKNOWN,
    SensorType::ACCELEROMETER,
    SensorType::INSTANT_MOTION_DETECT,
    SensorType::STATIONARY_DETECT,
    SensorType::GYROSCOPE,
    SensorType::UNCALIBRATED_GYROSCOPE,
    SensorType::GEOMAGNETIC_FIELD,
    SensorType::UNCALIBRATED_GEOMAGNETIC_FIELD,
    SensorType::PRESSURE,
    SensorType::LIGHT,
    SensorType::PROXIMITY,
    SensorType::STEP_DETECT,
    SensorType::STEP_COUNTER,
    SensorType::UNCALIBRATED_ACCELEROMETER,
    SensorType::ACCELEROMETER_TEMPERATURE,
    SensorType::GYROSCOPE_TEMPERATURE,
    SensorType::GEOMAGNETIC_FIELD_TEMPERATURE
  };
  return values;
}

inline const char * const *EnumNamesSensorType() {
  static const char * const names[60] = {
    "UNKNOWN",
    "ACCELEROMETER",
    "INSTANT_MOTION_DETECT",
    "STATIONARY_DETECT",
    "",
    "",
    "GYROSCOPE",
    "UNCALIBRATED_GYROSCOPE",
    "GEOMAGNETIC_FIELD",
    "UNCALIBRATED_GEOMAGNETIC_FIELD",
    "PRESSURE",
    "",
    "LIGHT",
    "PROXIMITY",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "STEP_DETECT",
    "STEP_COUNTER",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "UNCALIBRATED_ACCELEROMETER",
    "ACCELEROMETER_TEMPERATURE",
    "GYROSCOPE_TEMPERATURE",
    "GEOMAGNETIC_FIELD_TEMPERATURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  if (flatbuffers::IsOutRange(e, SensorType::UNKNOWN, SensorType::GEOMAGNETIC_FIELD_TEMPERATURE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorType()[index];
}

/// Represents a message to ask the nanoapp to create a timer that wakes up at
/// the given interval
struct TimerMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimerMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_WAKEUP_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint64_t wakeup_interval_ns() const {
    return GetField<uint64_t>(VT_WAKEUP_INTERVAL_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_WAKEUP_INTERVAL_NS) &&
           verifier.EndTable();
  }
};

struct TimerMessageBuilder {
  typedef TimerMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(TimerMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_wakeup_interval_ns(uint64_t wakeup_interval_ns) {
    fbb_.AddElement<uint64_t>(TimerMessage::VT_WAKEUP_INTERVAL_NS, wakeup_interval_ns, 0);
  }
  explicit TimerMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimerMessageBuilder &operator=(const TimerMessageBuilder &);
  flatbuffers::Offset<TimerMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimerMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimerMessage> CreateTimerMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t wakeup_interval_ns = 0) {
  TimerMessageBuilder builder_(_fbb);
  builder_.add_wakeup_interval_ns(wakeup_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start or stop WiFi scanning and
/// the scan interval to use if scanning is being started
struct WifiScanMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WifiScanMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_SCAN_INTERVAL_NS = 6,
    VT_SCAN_TYPE = 8,
    VT_RADIO_CHAIN = 10,
    VT_CHANNEL_SET = 12
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint64_t scan_interval_ns() const {
    return GetField<uint64_t>(VT_SCAN_INTERVAL_NS, 0);
  }
  chre::power_test::WifiScanType scan_type() const {
    return static_cast<chre::power_test::WifiScanType>(GetField<uint8_t>(VT_SCAN_TYPE, 0));
  }
  chre::power_test::WifiRadioChain radio_chain() const {
    return static_cast<chre::power_test::WifiRadioChain>(GetField<uint8_t>(VT_RADIO_CHAIN, 0));
  }
  chre::power_test::WifiChannelSet channel_set() const {
    return static_cast<chre::power_test::WifiChannelSet>(GetField<uint8_t>(VT_CHANNEL_SET, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_SCAN_INTERVAL_NS) &&
           VerifyField<uint8_t>(verifier, VT_SCAN_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_RADIO_CHAIN) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL_SET) &&
           verifier.EndTable();
  }
};

struct WifiScanMessageBuilder {
  typedef WifiScanMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(WifiScanMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_scan_interval_ns(uint64_t scan_interval_ns) {
    fbb_.AddElement<uint64_t>(WifiScanMessage::VT_SCAN_INTERVAL_NS, scan_interval_ns, 0);
  }
  void add_scan_type(chre::power_test::WifiScanType scan_type) {
    fbb_.AddElement<uint8_t>(WifiScanMessage::VT_SCAN_TYPE, static_cast<uint8_t>(scan_type), 0);
  }
  void add_radio_chain(chre::power_test::WifiRadioChain radio_chain) {
    fbb_.AddElement<uint8_t>(WifiScanMessage::VT_RADIO_CHAIN, static_cast<uint8_t>(radio_chain), 0);
  }
  void add_channel_set(chre::power_test::WifiChannelSet channel_set) {
    fbb_.AddElement<uint8_t>(WifiScanMessage::VT_CHANNEL_SET, static_cast<uint8_t>(channel_set), 0);
  }
  explicit WifiScanMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WifiScanMessageBuilder &operator=(const WifiScanMessageBuilder &);
  flatbuffers::Offset<WifiScanMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WifiScanMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiScanMessage> CreateWifiScanMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t scan_interval_ns = 0,
    chre::power_test::WifiScanType scan_type = chre::power_test::WifiScanType::ACTIVE,
    chre::power_test::WifiRadioChain radio_chain = chre::power_test::WifiRadioChain::DEFAULT,
    chre::power_test::WifiChannelSet channel_set = chre::power_test::WifiChannelSet::NON_DFS) {
  WifiScanMessageBuilder builder_(_fbb);
  builder_.add_scan_interval_ns(scan_interval_ns);
  builder_.add_channel_set(channel_set);
  builder_.add_radio_chain(radio_chain);
  builder_.add_scan_type(scan_type);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start or stop Gnss location
/// sampling at the requested interval
struct GnssLocationMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GnssLocationMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_SCAN_INTERVAL_MILLIS = 6,
    VT_MIN_TIME_TO_NEXT_FIX_MILLIS = 8
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint32_t scan_interval_millis() const {
    return GetField<uint32_t>(VT_SCAN_INTERVAL_MILLIS, 0);
  }
  uint32_t min_time_to_next_fix_millis() const {
    return GetField<uint32_t>(VT_MIN_TIME_TO_NEXT_FIX_MILLIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint32_t>(verifier, VT_SCAN_INTERVAL_MILLIS) &&
           VerifyField<uint32_t>(verifier, VT_MIN_TIME_TO_NEXT_FIX_MILLIS) &&
           verifier.EndTable();
  }
};

struct GnssLocationMessageBuilder {
  typedef GnssLocationMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(GnssLocationMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_scan_interval_millis(uint32_t scan_interval_millis) {
    fbb_.AddElement<uint32_t>(GnssLocationMessage::VT_SCAN_INTERVAL_MILLIS, scan_interval_millis, 0);
  }
  void add_min_time_to_next_fix_millis(uint32_t min_time_to_next_fix_millis) {
    fbb_.AddElement<uint32_t>(GnssLocationMessage::VT_MIN_TIME_TO_NEXT_FIX_MILLIS, min_time_to_next_fix_millis, 0);
  }
  explicit GnssLocationMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GnssLocationMessageBuilder &operator=(const GnssLocationMessageBuilder &);
  flatbuffers::Offset<GnssLocationMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GnssLocationMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<GnssLocationMessage> CreateGnssLocationMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint32_t scan_interval_millis = 0,
    uint32_t min_time_to_next_fix_millis = 0) {
  GnssLocationMessageBuilder builder_(_fbb);
  builder_.add_min_time_to_next_fix_millis(min_time_to_next_fix_millis);
  builder_.add_scan_interval_millis(scan_interval_millis);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start or stop querying the cell
/// modem for the latest cell scan results on the given interval
struct CellQueryMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellQueryMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_QUERY_INTERVAL_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint64_t query_interval_ns() const {
    return GetField<uint64_t>(VT_QUERY_INTERVAL_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_QUERY_INTERVAL_NS) &&
           verifier.EndTable();
  }
};

struct CellQueryMessageBuilder {
  typedef CellQueryMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(CellQueryMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_query_interval_ns(uint64_t query_interval_ns) {
    fbb_.AddElement<uint64_t>(CellQueryMessage::VT_QUERY_INTERVAL_NS, query_interval_ns, 0);
  }
  explicit CellQueryMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellQueryMessageBuilder &operator=(const CellQueryMessageBuilder &);
  flatbuffers::Offset<CellQueryMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellQueryMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellQueryMessage> CreateCellQueryMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t query_interval_ns = 0) {
  CellQueryMessageBuilder builder_(_fbb);
  builder_.add_query_interval_ns(query_interval_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start / stop requesting Audio
/// data buffered at given interval. Note: If there is more than one audio
/// source, the nanoapp will only request audio from the first source.
struct AudioRequestMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioRequestMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_BUFFER_DURATION_NS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  /// The buffer duration is also used as the interval for how often
  /// the buffer should be delivered to the nanoapp.
  uint64_t buffer_duration_ns() const {
    return GetField<uint64_t>(VT_BUFFER_DURATION_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint64_t>(verifier, VT_BUFFER_DURATION_NS) &&
           verifier.EndTable();
  }
};

struct AudioRequestMessageBuilder {
  typedef AudioRequestMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(AudioRequestMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_buffer_duration_ns(uint64_t buffer_duration_ns) {
    fbb_.AddElement<uint64_t>(AudioRequestMessage::VT_BUFFER_DURATION_NS, buffer_duration_ns, 0);
  }
  explicit AudioRequestMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AudioRequestMessageBuilder &operator=(const AudioRequestMessageBuilder &);
  flatbuffers::Offset<AudioRequestMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioRequestMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioRequestMessage> CreateAudioRequestMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint64_t buffer_duration_ns = 0) {
  AudioRequestMessageBuilder builder_(_fbb);
  builder_.add_buffer_duration_ns(buffer_duration_ns);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start / stop sampling / batching
/// a given sensor
struct SensorRequestMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SensorRequestMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_SENSOR = 6,
    VT_SAMPLING_INTERVAL_NS = 8,
    VT_LATENCY_NS = 10
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  chre::power_test::SensorType sensor() const {
    return static_cast<chre::power_test::SensorType>(GetField<uint8_t>(VT_SENSOR, 0));
  }
  uint64_t sampling_interval_ns() const {
    return GetField<uint64_t>(VT_SAMPLING_INTERVAL_NS, 0);
  }
  uint64_t latency_ns() const {
    return GetField<uint64_t>(VT_LATENCY_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint8_t>(verifier, VT_SENSOR) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLING_INTERVAL_NS) &&
           VerifyField<uint64_t>(verifier, VT_LATENCY_NS) &&
           verifier.EndTable();
  }
};

struct SensorRequestMessageBuilder {
  typedef SensorRequestMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(SensorRequestMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_sensor(chre::power_test::SensorType sensor) {
    fbb_.AddElement<uint8_t>(SensorRequestMessage::VT_SENSOR, static_cast<uint8_t>(sensor), 0);
  }
  void add_sampling_interval_ns(uint64_t sampling_interval_ns) {
    fbb_.AddElement<uint64_t>(SensorRequestMessage::VT_SAMPLING_INTERVAL_NS, sampling_interval_ns, 0);
  }
  void add_latency_ns(uint64_t latency_ns) {
    fbb_.AddElement<uint64_t>(SensorRequestMessage::VT_LATENCY_NS, latency_ns, 0);
  }
  explicit SensorRequestMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SensorRequestMessageBuilder &operator=(const SensorRequestMessageBuilder &);
  flatbuffers::Offset<SensorRequestMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SensorRequestMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<SensorRequestMessage> CreateSensorRequestMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    chre::power_test::SensorType sensor = chre::power_test::SensorType::UNKNOWN,
    uint64_t sampling_interval_ns = 0,
    uint64_t latency_ns = 0) {
  SensorRequestMessageBuilder builder_(_fbb);
  builder_.add_latency_ns(latency_ns);
  builder_.add_sampling_interval_ns(sampling_interval_ns);
  builder_.add_sensor(sensor);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to enable / disable break-it mode inside the nanoapp.
/// Break-it mode enables WiFi / GNSS / Cell to be queried every second and
/// enables all sensors at their fastest sampling rate.
struct BreakItMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BreakItMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           verifier.EndTable();
  }
};

struct BreakItMessageBuilder {
  typedef BreakItMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(BreakItMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  explicit BreakItMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BreakItMessageBuilder &operator=(const BreakItMessageBuilder &);
  flatbuffers::Offset<BreakItMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BreakItMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<BreakItMessage> CreateBreakItMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false) {
  BreakItMessageBuilder builder_(_fbb);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Indicates whether the nanoapp successfully performed the requested action.
/// Any failures will be printed to the logs.
struct NanoappResponseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NanoappResponseMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct NanoappResponseMessageBuilder {
  typedef NanoappResponseMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(NanoappResponseMessage::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit NanoappResponseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NanoappResponseMessageBuilder &operator=(const NanoappResponseMessageBuilder &);
  flatbuffers::Offset<NanoappResponseMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NanoappResponseMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<NanoappResponseMessage> CreateNanoappResponseMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  NanoappResponseMessageBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start or stop Gnss measurement
/// sampling at the requested interval
struct GnssMeasurementMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GnssMeasurementMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENABLE = 4,
    VT_MIN_INTERVAL_MILLIS = 6
  };
  bool enable() const {
    return GetField<uint8_t>(VT_ENABLE, 0) != 0;
  }
  uint32_t min_interval_millis() const {
    return GetField<uint32_t>(VT_MIN_INTERVAL_MILLIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENABLE) &&
           VerifyField<uint32_t>(verifier, VT_MIN_INTERVAL_MILLIS) &&
           verifier.EndTable();
  }
};

struct GnssMeasurementMessageBuilder {
  typedef GnssMeasurementMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enable(bool enable) {
    fbb_.AddElement<uint8_t>(GnssMeasurementMessage::VT_ENABLE, static_cast<uint8_t>(enable), 0);
  }
  void add_min_interval_millis(uint32_t min_interval_millis) {
    fbb_.AddElement<uint32_t>(GnssMeasurementMessage::VT_MIN_INTERVAL_MILLIS, min_interval_millis, 0);
  }
  explicit GnssMeasurementMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GnssMeasurementMessageBuilder &operator=(const GnssMeasurementMessageBuilder &);
  flatbuffers::Offset<GnssMeasurementMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GnssMeasurementMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<GnssMeasurementMessage> CreateGnssMeasurementMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool enable = false,
    uint32_t min_interval_millis = 0) {
  GnssMeasurementMessageBuilder builder_(_fbb);
  builder_.add_min_interval_millis(min_interval_millis);
  builder_.add_enable(enable);
  return builder_.Finish();
}

/// Represents a message to ask the nanoapp to start a NAN subscription session.
/// See chreWifiNanSubscribeConfig for how to fill in this message.
struct WifiNanSubMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WifiNanSubMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUB_TYPE = 4,
    VT_SERVICE_NAME = 6,
    VT_SERVICE_SPECIFIC_INFO = 8,
    VT_MATCH_FILTER = 10
  };
  uint8_t sub_type() const {
    return GetField<uint8_t>(VT_SUB_TYPE, 0);
  }
  const flatbuffers::Vector<uint8_t> *service_name() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERVICE_NAME);
  }
  const flatbuffers::Vector<uint8_t> *service_specific_info() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERVICE_SPECIFIC_INFO);
  }
  const flatbuffers::Vector<uint8_t> *match_filter() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MATCH_FILTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUB_TYPE) &&
           VerifyOffset(verifier, VT_SERVICE_NAME) &&
           verifier.VerifyVector(service_name()) &&
           VerifyOffset(verifier, VT_SERVICE_SPECIFIC_INFO) &&
           verifier.VerifyVector(service_specific_info()) &&
           VerifyOffset(verifier, VT_MATCH_FILTER) &&
           verifier.VerifyVector(match_filter()) &&
           verifier.EndTable();
  }
};

struct WifiNanSubMessageBuilder {
  typedef WifiNanSubMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sub_type(uint8_t sub_type) {
    fbb_.AddElement<uint8_t>(WifiNanSubMessage::VT_SUB_TYPE, sub_type, 0);
  }
  void add_service_name(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> service_name) {
    fbb_.AddOffset(WifiNanSubMessage::VT_SERVICE_NAME, service_name);
  }
  void add_service_specific_info(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> service_specific_info) {
    fbb_.AddOffset(WifiNanSubMessage::VT_SERVICE_SPECIFIC_INFO, service_specific_info);
  }
  void add_match_filter(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> match_filter) {
    fbb_.AddOffset(WifiNanSubMessage::VT_MATCH_FILTER, match_filter);
  }
  explicit WifiNanSubMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WifiNanSubMessageBuilder &operator=(const WifiNanSubMessageBuilder &);
  flatbuffers::Offset<WifiNanSubMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WifiNanSubMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiNanSubMessage> CreateWifiNanSubMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sub_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> service_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> service_specific_info = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> match_filter = 0) {
  WifiNanSubMessageBuilder builder_(_fbb);
  builder_.add_match_filter(match_filter);
  builder_.add_service_specific_info(service_specific_info);
  builder_.add_service_name(service_name);
  builder_.add_sub_type(sub_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<WifiNanSubMessage> CreateWifiNanSubMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sub_type = 0,
    const std::vector<uint8_t> *service_name = nullptr,
    const std::vector<uint8_t> *service_specific_info = nullptr,
    const std::vector<uint8_t> *match_filter = nullptr) {
  auto service_name__ = service_name ? _fbb.CreateVector<uint8_t>(*service_name) : 0;
  auto service_specific_info__ = service_specific_info ? _fbb.CreateVector<uint8_t>(*service_specific_info) : 0;
  auto match_filter__ = match_filter ? _fbb.CreateVector<uint8_t>(*match_filter) : 0;
  return chre::power_test::CreateWifiNanSubMessage(
      _fbb,
      sub_type,
      service_name__,
      service_specific_info__,
      match_filter__);
}

/// Represents a messages to ask the nanoapp to cancel an ongoing subscription
struct WifiNanSubCancelMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WifiNanSubCancelMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBSCRIPTION_ID = 4
  };
  uint32_t subscription_id() const {
    return GetField<uint32_t>(VT_SUBSCRIPTION_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SUBSCRIPTION_ID) &&
           verifier.EndTable();
  }
};

struct WifiNanSubCancelMessageBuilder {
  typedef WifiNanSubCancelMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subscription_id(uint32_t subscription_id) {
    fbb_.AddElement<uint32_t>(WifiNanSubCancelMessage::VT_SUBSCRIPTION_ID, subscription_id, 0);
  }
  explicit WifiNanSubCancelMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WifiNanSubCancelMessageBuilder &operator=(const WifiNanSubCancelMessageBuilder &);
  flatbuffers::Offset<WifiNanSubCancelMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WifiNanSubCancelMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiNanSubCancelMessage> CreateWifiNanSubCancelMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t subscription_id = 0) {
  WifiNanSubCancelMessageBuilder builder_(_fbb);
  builder_.add_subscription_id(subscription_id);
  return builder_.Finish();
}

/// Represents a message from the nanoapp indicating whether a subscription
/// request succeeded
struct WifiNanSubResponseMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WifiNanSubResponseMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_SUBSCRIPTION_ID = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  uint32_t subscription_id() const {
    return GetField<uint32_t>(VT_SUBSCRIPTION_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<uint32_t>(verifier, VT_SUBSCRIPTION_ID) &&
           verifier.EndTable();
  }
};

struct WifiNanSubResponseMessageBuilder {
  typedef WifiNanSubResponseMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(WifiNanSubResponseMessage::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_subscription_id(uint32_t subscription_id) {
    fbb_.AddElement<uint32_t>(WifiNanSubResponseMessage::VT_SUBSCRIPTION_ID, subscription_id, 0);
  }
  explicit WifiNanSubResponseMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WifiNanSubResponseMessageBuilder &operator=(const WifiNanSubResponseMessageBuilder &);
  flatbuffers::Offset<WifiNanSubResponseMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WifiNanSubResponseMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiNanSubResponseMessage> CreateWifiNanSubResponseMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    uint32_t subscription_id = 0) {
  WifiNanSubResponseMessageBuilder builder_(_fbb);
  builder_.add_subscription_id(subscription_id);
  builder_.add_success(success);
  return builder_.Finish();
}

}  // namespace power_test
}  // namespace chre

#endif  // FLATBUFFERS_GENERATED_CHREPOWERTEST_CHRE_POWER_TEST_H_
