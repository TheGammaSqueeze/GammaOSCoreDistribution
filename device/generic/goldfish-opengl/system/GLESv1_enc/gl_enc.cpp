// Generated Code - DO NOT EDIT !!
// generated by 'emugen'


#include <string.h>
#include "gl_opcodes.h"

#include "gl_enc.h"


#include <vector>

#include <stdio.h>

#include "android/base/Tracing.h"

#include "EncoderDebug.h"

namespace {

void enc_unsupported()
{
	ALOGE("Function is unsupported\n");
}

void glAlphaFunc_enc(void *self , GLenum func, GLclampf ref)
{
	ENCODER_DEBUG_LOG("glAlphaFunc(func:0x%08x, ref:%f)", func, ref);
	AEMU_SCOPED_TRACE("glAlphaFunc encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glAlphaFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearColor_enc(void *self , GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	ENCODER_DEBUG_LOG("glClearColor(red:%f, green:%f, blue:%f, alpha:%f)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glClearColor encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearColor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearDepthf_enc(void *self , GLclampf depth)
{
	ENCODER_DEBUG_LOG("glClearDepthf(depth:%f)", depth);
	AEMU_SCOPED_TRACE("glClearDepthf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearDepthf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &depth, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClipPlanef_enc(void *self , GLenum plane, const GLfloat* equation)
{
	ENCODER_DEBUG_LOG("glClipPlanef(plane:0x%08x, equation:0x%08x)", plane, equation);
	AEMU_SCOPED_TRACE("glClipPlanef encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_equation =  (4 * sizeof(float));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_equation + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClipPlanef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &plane, 4); ptr += 4;
	memcpy(ptr, &__size_equation, 4); ptr += 4;
	memcpy(ptr, equation, __size_equation);ptr += __size_equation;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColor4f_enc(void *self , GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	ENCODER_DEBUG_LOG("glColor4f(red:%f, green:%f, blue:%f, alpha:%f)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glColor4f encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColor4f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthRangef_enc(void *self , GLclampf zNear, GLclampf zFar)
{
	ENCODER_DEBUG_LOG("glDepthRangef(zNear:%f, zFar:%f)", zNear, zFar);
	AEMU_SCOPED_TRACE("glDepthRangef encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthRangef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFogf_enc(void *self , GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glFogf(pname:0x%08x, param:%f)", pname, param);
	AEMU_SCOPED_TRACE("glFogf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFogf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFogfv_enc(void *self , GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glFogfv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glFogfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFogfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFrustumf_enc(void *self , GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	ENCODER_DEBUG_LOG("glFrustumf(left:%f, right:%f, bottom:%f, top:%f, zNear:%f, zFar:%f)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glFrustumf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFrustumf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetClipPlanef_enc(void *self , GLenum pname, GLfloat* eqn)
{
	ENCODER_DEBUG_LOG("glGetClipPlanef(pname:0x%08x, eqn:0x%08x)", pname, eqn);
	AEMU_SCOPED_TRACE("glGetClipPlanef encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_eqn =  (4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetClipPlanef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_eqn, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(eqn, __size_eqn);
	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetClipPlanef: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetFloatv_enc(void *self , GLenum pname, GLfloat* params)
{
	ENCODER_DEBUG_LOG("glGetFloatv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glGetFloatv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetFloatv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetFloatv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetLightfv_enc(void *self , GLenum light, GLenum pname, GLfloat* params)
{
	ENCODER_DEBUG_LOG("glGetLightfv(light:0x%08x, pname:0x%08x, params:0x%08x)", light, pname, params);
	AEMU_SCOPED_TRACE("glGetLightfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetLightfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetLightfv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetMaterialfv_enc(void *self , GLenum face, GLenum pname, GLfloat* params)
{
	ENCODER_DEBUG_LOG("glGetMaterialfv(face:0x%08x, pname:0x%08x, params:0x%08x)", face, pname, params);
	AEMU_SCOPED_TRACE("glGetMaterialfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetMaterialfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetMaterialfv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexEnvfv_enc(void *self , GLenum env, GLenum pname, GLfloat* params)
{
	ENCODER_DEBUG_LOG("glGetTexEnvfv(env:0x%08x, pname:0x%08x, params:0x%08x)", env, pname, params);
	AEMU_SCOPED_TRACE("glGetTexEnvfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexEnvfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &env, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexEnvfv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexParameterfv_enc(void *self , GLenum target, GLenum pname, GLfloat* params)
{
	ENCODER_DEBUG_LOG("glGetTexParameterfv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glGetTexParameterfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexParameterfv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glLightModelf_enc(void *self , GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glLightModelf(pname:0x%08x, param:%f)", pname, param);
	AEMU_SCOPED_TRACE("glLightModelf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightModelf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightModelfv_enc(void *self , GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glLightModelfv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glLightModelfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightModelfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightf_enc(void *self , GLenum light, GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glLightf(light:0x%08x, pname:0x%08x, param:%f)", light, pname, param);
	AEMU_SCOPED_TRACE("glLightf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightfv_enc(void *self , GLenum light, GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glLightfv(light:0x%08x, pname:0x%08x, params:0x%08x)", light, pname, params);
	AEMU_SCOPED_TRACE("glLightfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLineWidth_enc(void *self , GLfloat width)
{
	ENCODER_DEBUG_LOG("glLineWidth(width:%f)", width);
	AEMU_SCOPED_TRACE("glLineWidth encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLineWidth;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &width, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLoadMatrixf_enc(void *self , const GLfloat* m)
{
	ENCODER_DEBUG_LOG("glLoadMatrixf(m:0x%08x)", m);
	AEMU_SCOPED_TRACE("glLoadMatrixf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_m =  (16 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_m + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLoadMatrixf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_m, 4); ptr += 4;
	memcpy(ptr, m, __size_m);ptr += __size_m;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMaterialf_enc(void *self , GLenum face, GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glMaterialf(face:0x%08x, pname:0x%08x, param:%f)", face, pname, param);
	AEMU_SCOPED_TRACE("glMaterialf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMaterialf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMaterialfv_enc(void *self , GLenum face, GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glMaterialfv(face:0x%08x, pname:0x%08x, params:0x%08x)", face, pname, params);
	AEMU_SCOPED_TRACE("glMaterialfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMaterialfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMultMatrixf_enc(void *self , const GLfloat* m)
{
	ENCODER_DEBUG_LOG("glMultMatrixf(m:0x%08x)", m);
	AEMU_SCOPED_TRACE("glMultMatrixf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_m =  (16 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_m + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMultMatrixf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_m, 4); ptr += 4;
	memcpy(ptr, m, __size_m);ptr += __size_m;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMultiTexCoord4f_enc(void *self , GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
	ENCODER_DEBUG_LOG("glMultiTexCoord4f(target:0x%08x, s:%f, t:%f, r:%f, q:%f)", target, s, t, r, q);
	AEMU_SCOPED_TRACE("glMultiTexCoord4f encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMultiTexCoord4f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &s, 4); ptr += 4;
		memcpy(ptr, &t, 4); ptr += 4;
		memcpy(ptr, &r, 4); ptr += 4;
		memcpy(ptr, &q, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glNormal3f_enc(void *self , GLfloat nx, GLfloat ny, GLfloat nz)
{
	ENCODER_DEBUG_LOG("glNormal3f(nx:%f, ny:%f, nz:%f)", nx, ny, nz);
	AEMU_SCOPED_TRACE("glNormal3f encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glNormal3f;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &nx, 4); ptr += 4;
		memcpy(ptr, &ny, 4); ptr += 4;
		memcpy(ptr, &nz, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glOrthof_enc(void *self , GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	ENCODER_DEBUG_LOG("glOrthof(left:%f, right:%f, bottom:%f, top:%f, zNear:%f, zFar:%f)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glOrthof encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glOrthof;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointParameterf_enc(void *self , GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glPointParameterf(pname:0x%08x, param:%f)", pname, param);
	AEMU_SCOPED_TRACE("glPointParameterf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointParameterf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointParameterfv_enc(void *self , GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glPointParameterfv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glPointParameterfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointSize_enc(void *self , GLfloat size)
{
	ENCODER_DEBUG_LOG("glPointSize(size:%f)", size);
	AEMU_SCOPED_TRACE("glPointSize encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointSize;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPolygonOffset_enc(void *self , GLfloat factor, GLfloat units)
{
	ENCODER_DEBUG_LOG("glPolygonOffset(factor:%f, units:%f)", factor, units);
	AEMU_SCOPED_TRACE("glPolygonOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPolygonOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &factor, 4); ptr += 4;
		memcpy(ptr, &units, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glRotatef_enc(void *self , GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
	ENCODER_DEBUG_LOG("glRotatef(angle:%f, x:%f, y:%f, z:%f)", angle, x, y, z);
	AEMU_SCOPED_TRACE("glRotatef encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glRotatef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &angle, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glScalef_enc(void *self , GLfloat x, GLfloat y, GLfloat z)
{
	ENCODER_DEBUG_LOG("glScalef(x:%f, y:%f, z:%f)", x, y, z);
	AEMU_SCOPED_TRACE("glScalef encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glScalef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnvf_enc(void *self , GLenum target, GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glTexEnvf(target:0x%08x, pname:0x%08x, param:%f)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexEnvf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnvf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnvfv_enc(void *self , GLenum target, GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glTexEnvfv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexEnvfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnvfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameterf_enc(void *self , GLenum target, GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glTexParameterf(target:0x%08x, pname:0x%08x, param:%f)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexParameterf encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterf;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameterfv_enc(void *self , GLenum target, GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glTexParameterfv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexParameterfv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterfv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTranslatef_enc(void *self , GLfloat x, GLfloat y, GLfloat z)
{
	ENCODER_DEBUG_LOG("glTranslatef(x:%f, y:%f, z:%f)", x, y, z);
	AEMU_SCOPED_TRACE("glTranslatef encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTranslatef;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glActiveTexture_enc(void *self , GLenum texture)
{
	ENCODER_DEBUG_LOG("glActiveTexture(texture:0x%08x)", texture);
	AEMU_SCOPED_TRACE("glActiveTexture encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glActiveTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glAlphaFuncx_enc(void *self , GLenum func, GLclampx ref)
{
	ENCODER_DEBUG_LOG("glAlphaFuncx(func:0x%08x, ref:0x%08x)", func, ref);
	AEMU_SCOPED_TRACE("glAlphaFuncx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glAlphaFuncx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindBuffer_enc(void *self , GLenum target, GLuint buffer)
{
	ENCODER_DEBUG_LOG("glBindBuffer(target:0x%08x, buffer:%u)", target, buffer);
	AEMU_SCOPED_TRACE("glBindBuffer encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &buffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindTexture_enc(void *self , GLenum target, GLuint texture)
{
	ENCODER_DEBUG_LOG("glBindTexture(target:0x%08x, texture:%u)", target, texture);
	AEMU_SCOPED_TRACE("glBindTexture encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendFunc_enc(void *self , GLenum sfactor, GLenum dfactor)
{
	ENCODER_DEBUG_LOG("glBlendFunc(sfactor:0x%08x, dfactor:0x%08x)", sfactor, dfactor);
	AEMU_SCOPED_TRACE("glBlendFunc encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &sfactor, 4); ptr += 4;
		memcpy(ptr, &dfactor, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBufferData_enc(void *self , GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)
{
	ENCODER_DEBUG_LOG("glBufferData(target:0x%08x, size:0x%08lx, data:0x%08x, usage:0x%08x)", target, size, data, usage);
	AEMU_SCOPED_TRACE("glBufferData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  size : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBufferData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	if (data != NULL) memcpy(ptr, data, __size_data);ptr += __size_data;
		memcpy(ptr, &usage, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBufferSubData_enc(void *self , GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data)
{
	ENCODER_DEBUG_LOG("glBufferSubData(target:0x%08x, offset:0x%08lx, size:0x%08lx, data:0x%08x)", target, offset, size, data);
	AEMU_SCOPED_TRACE("glBufferSubData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  size : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBufferSubData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	if (data != NULL) memcpy(ptr, data, __size_data);ptr += __size_data;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClear_enc(void *self , GLbitfield mask)
{
	ENCODER_DEBUG_LOG("glClear(mask:0x%08x)", mask);
	AEMU_SCOPED_TRACE("glClear encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClear;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearColorx_enc(void *self , GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
	ENCODER_DEBUG_LOG("glClearColorx(red:0x%08x, green:0x%08x, blue:0x%08x, alpha:0x%08x)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glClearColorx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearColorx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearDepthx_enc(void *self , GLclampx depth)
{
	ENCODER_DEBUG_LOG("glClearDepthx(depth:0x%08x)", depth);
	AEMU_SCOPED_TRACE("glClearDepthx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearDepthx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &depth, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearStencil_enc(void *self , GLint s)
{
	ENCODER_DEBUG_LOG("glClearStencil(s:%d)", s);
	AEMU_SCOPED_TRACE("glClearStencil encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearStencil;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &s, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClientActiveTexture_enc(void *self , GLenum texture)
{
	ENCODER_DEBUG_LOG("glClientActiveTexture(texture:0x%08x)", texture);
	AEMU_SCOPED_TRACE("glClientActiveTexture encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClientActiveTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColor4ub_enc(void *self , GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
	ENCODER_DEBUG_LOG("glColor4ub(red:0x%02x, green:0x%02x, blue:0x%02x, alpha:0x%02x)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glColor4ub encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 1 + 1 + 1 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColor4ub;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 1); ptr += 1;
		memcpy(ptr, &green, 1); ptr += 1;
		memcpy(ptr, &blue, 1); ptr += 1;
		memcpy(ptr, &alpha, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColor4x_enc(void *self , GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
	ENCODER_DEBUG_LOG("glColor4x(red:0x%08x, green:0x%08x, blue:0x%08x, alpha:0x%08x)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glColor4x encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColor4x;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColorMask_enc(void *self , GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	ENCODER_DEBUG_LOG("glColorMask(red:%d, green:%d, blue:%d, alpha:%d)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glColorMask encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 1 + 1 + 1 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColorMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 1); ptr += 1;
		memcpy(ptr, &green, 1); ptr += 1;
		memcpy(ptr, &blue, 1); ptr += 1;
		memcpy(ptr, &alpha, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCompressedTexImage2D_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data)
{
	ENCODER_DEBUG_LOG("glCompressedTexImage2D(target:0x%08x, level:%d, internalformat:0x%08x, width:%d, height:%d, border:%d, imageSize:%d, data:0x%08x)", target, level, internalformat, width, height, border, imageSize, data);
	AEMU_SCOPED_TRACE("glCompressedTexImage2D encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCompressedTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	if (data != NULL) memcpy(ptr, data, __size_data);ptr += __size_data;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCompressedTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data)
{
	ENCODER_DEBUG_LOG("glCompressedTexSubImage2D(target:0x%08x, level:%d, xoffset:%d, yoffset:%d, width:%d, height:%d, format:0x%08x, imageSize:%d, data:0x%08x)", target, level, xoffset, yoffset, width, height, format, imageSize, data);
	AEMU_SCOPED_TRACE("glCompressedTexSubImage2D encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data = ((data != NULL) ?  imageSize : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_data + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCompressedTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &imageSize, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	if (data != NULL) memcpy(ptr, data, __size_data);ptr += __size_data;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCopyTexImage2D_enc(void *self , GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	ENCODER_DEBUG_LOG("glCopyTexImage2D(target:0x%08x, level:%d, internalformat:0x%08x, x:%d, y:%d, width:%d, height:%d, border:%d)", target, level, internalformat, x, y, width, height, border);
	AEMU_SCOPED_TRACE("glCopyTexImage2D encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCopyTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCopyTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	ENCODER_DEBUG_LOG("glCopyTexSubImage2D(target:0x%08x, level:%d, xoffset:%d, yoffset:%d, x:%d, y:%d, width:%d, height:%d)", target, level, xoffset, yoffset, x, y, width, height);
	AEMU_SCOPED_TRACE("glCopyTexSubImage2D encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCopyTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glCullFace_enc(void *self , GLenum mode)
{
	ENCODER_DEBUG_LOG("glCullFace(mode:0x%08x)", mode);
	AEMU_SCOPED_TRACE("glCullFace encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCullFace;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteBuffers_enc(void *self , GLsizei n, const GLuint* buffers)
{
	ENCODER_DEBUG_LOG("glDeleteBuffers(n:%d, buffers:0x%08x)", n, buffers);
	AEMU_SCOPED_TRACE("glDeleteBuffers encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_buffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_buffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteBuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_buffers, 4); ptr += 4;
	memcpy(ptr, buffers, __size_buffers);ptr += __size_buffers;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteTextures_enc(void *self , GLsizei n, const GLuint* textures)
{
	ENCODER_DEBUG_LOG("glDeleteTextures(n:%d, textures:0x%08x)", n, textures);
	AEMU_SCOPED_TRACE("glDeleteTextures encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_textures =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_textures + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteTextures;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_textures, 4); ptr += 4;
	memcpy(ptr, textures, __size_textures);ptr += __size_textures;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthFunc_enc(void *self , GLenum func)
{
	ENCODER_DEBUG_LOG("glDepthFunc(func:0x%08x)", func);
	AEMU_SCOPED_TRACE("glDepthFunc encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthMask_enc(void *self , GLboolean flag)
{
	ENCODER_DEBUG_LOG("glDepthMask(flag:%d)", flag);
	AEMU_SCOPED_TRACE("glDepthMask encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &flag, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthRangex_enc(void *self , GLclampx zNear, GLclampx zFar)
{
	ENCODER_DEBUG_LOG("glDepthRangex(zNear:0x%08x, zFar:0x%08x)", zNear, zFar);
	AEMU_SCOPED_TRACE("glDepthRangex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthRangex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDisable_enc(void *self , GLenum cap)
{
	ENCODER_DEBUG_LOG("glDisable(cap:0x%08x)", cap);
	AEMU_SCOPED_TRACE("glDisable encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDisable;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDisableClientState_enc(void *self , GLenum array)
{
	ENCODER_DEBUG_LOG("glDisableClientState(array:0x%08x)", array);
	AEMU_SCOPED_TRACE("glDisableClientState encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDisableClientState;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawArrays_enc(void *self , GLenum mode, GLint first, GLsizei count)
{
	ENCODER_DEBUG_LOG("glDrawArrays(mode:0x%08x, first:%d, count:%d)", mode, first, count);
	AEMU_SCOPED_TRACE("glDrawArrays encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawArrays;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &first, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEnable_enc(void *self , GLenum cap)
{
	ENCODER_DEBUG_LOG("glEnable(cap:0x%08x)", cap);
	AEMU_SCOPED_TRACE("glEnable encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEnable;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEnableClientState_enc(void *self , GLenum array)
{
	ENCODER_DEBUG_LOG("glEnableClientState(array:0x%08x)", array);
	AEMU_SCOPED_TRACE("glEnableClientState encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEnableClientState;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFinish_enc(void *self )
{
	ENCODER_DEBUG_LOG("glFinish()");
	AEMU_SCOPED_TRACE("glFinish encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFinish;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFlush_enc(void *self )
{
	ENCODER_DEBUG_LOG("glFlush()");
	AEMU_SCOPED_TRACE("glFlush encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFlush;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFogx_enc(void *self , GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glFogx(pname:0x%08x, param:0x%08x)", pname, param);
	AEMU_SCOPED_TRACE("glFogx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFogx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFogxv_enc(void *self , GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glFogxv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glFogxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFogxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFrontFace_enc(void *self , GLenum mode)
{
	ENCODER_DEBUG_LOG("glFrontFace(mode:0x%08x)", mode);
	AEMU_SCOPED_TRACE("glFrontFace encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFrontFace;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFrustumx_enc(void *self , GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	ENCODER_DEBUG_LOG("glFrustumx(left:0x%08x, right:0x%08x, bottom:0x%08x, top:0x%08x, zNear:0x%08x, zFar:0x%08x)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glFrustumx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFrustumx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetBooleanv_enc(void *self , GLenum pname, GLboolean* params)
{
	ENCODER_DEBUG_LOG("glGetBooleanv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glGetBooleanv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLboolean));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetBooleanv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetBooleanv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetBufferParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetBufferParameteriv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glGetBufferParameteriv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetBufferParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetBufferParameteriv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glClipPlanex_enc(void *self , GLenum pname, const GLfixed* eqn)
{
	ENCODER_DEBUG_LOG("glClipPlanex(pname:0x%08x, eqn:0x%08x)", pname, eqn);
	AEMU_SCOPED_TRACE("glClipPlanex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_eqn =  (4 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_eqn + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClipPlanex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_eqn, 4); ptr += 4;
	memcpy(ptr, eqn, __size_eqn);ptr += __size_eqn;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenBuffers_enc(void *self , GLsizei n, GLuint* buffers)
{
	ENCODER_DEBUG_LOG("glGenBuffers(n:%d, buffers:0x%08x)", n, buffers);
	AEMU_SCOPED_TRACE("glGenBuffers encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_buffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenBuffers;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_buffers, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(buffers, __size_buffers);
	if (useChecksum) checksumCalculator->addBuffer(buffers, __size_buffers);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGenBuffers: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGenTextures_enc(void *self , GLsizei n, GLuint* textures)
{
	ENCODER_DEBUG_LOG("glGenTextures(n:%d, textures:0x%08x)", n, textures);
	AEMU_SCOPED_TRACE("glGenTextures encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_textures =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenTextures;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_textures, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(textures, __size_textures);
	if (useChecksum) checksumCalculator->addBuffer(textures, __size_textures);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGenTextures: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

GLenum glGetError_enc(void *self )
{
	ENCODER_DEBUG_LOG("glGetError()");
	AEMU_SCOPED_TRACE("glGetError encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetError;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLenum retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetError: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glGetFixedv_enc(void *self , GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetFixedv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glGetFixedv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetFixedv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetFixedv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetIntegerv_enc(void *self , GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetIntegerv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glGetIntegerv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetIntegerv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetIntegerv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetLightxv_enc(void *self , GLenum light, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetLightxv(light:0x%08x, pname:0x%08x, params:0x%08x)", light, pname, params);
	AEMU_SCOPED_TRACE("glGetLightxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetLightxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetLightxv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetMaterialxv_enc(void *self , GLenum face, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetMaterialxv(face:0x%08x, pname:0x%08x, params:0x%08x)", face, pname, params);
	AEMU_SCOPED_TRACE("glGetMaterialxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetMaterialxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetMaterialxv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexEnviv_enc(void *self , GLenum env, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetTexEnviv(env:0x%08x, pname:0x%08x, params:0x%08x)", env, pname, params);
	AEMU_SCOPED_TRACE("glGetTexEnviv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexEnviv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &env, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexEnviv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexEnvxv_enc(void *self , GLenum env, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetTexEnvxv(env:0x%08x, pname:0x%08x, params:0x%08x)", env, pname, params);
	AEMU_SCOPED_TRACE("glGetTexEnvxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexEnvxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &env, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexEnvxv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexParameteriv_enc(void *self , GLenum target, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetTexParameteriv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glGetTexParameteriv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexParameteriv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexParameterxv_enc(void *self , GLenum target, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetTexParameterxv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glGetTexParameterxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexParameterxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexParameterxv: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glHint_enc(void *self , GLenum target, GLenum mode)
{
	ENCODER_DEBUG_LOG("glHint(target:0x%08x, mode:0x%08x)", target, mode);
	AEMU_SCOPED_TRACE("glHint encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glHint;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLboolean glIsBuffer_enc(void *self , GLuint buffer)
{
	ENCODER_DEBUG_LOG("glIsBuffer(buffer:%u)", buffer);
	AEMU_SCOPED_TRACE("glIsBuffer encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsBuffer;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &buffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glIsBuffer: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsEnabled_enc(void *self , GLenum cap)
{
	ENCODER_DEBUG_LOG("glIsEnabled(cap:0x%08x)", cap);
	AEMU_SCOPED_TRACE("glIsEnabled encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsEnabled;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &cap, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glIsEnabled: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glIsTexture_enc(void *self , GLuint texture)
{
	ENCODER_DEBUG_LOG("glIsTexture(texture:%u)", texture);
	AEMU_SCOPED_TRACE("glIsTexture encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsTexture;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glIsTexture: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glLightModelx_enc(void *self , GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glLightModelx(pname:0x%08x, param:0x%08x)", pname, param);
	AEMU_SCOPED_TRACE("glLightModelx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightModelx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightModelxv_enc(void *self , GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glLightModelxv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glLightModelxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightModelxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightx_enc(void *self , GLenum light, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glLightx(light:0x%08x, pname:0x%08x, param:0x%08x)", light, pname, param);
	AEMU_SCOPED_TRACE("glLightx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightxv_enc(void *self , GLenum light, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glLightxv(light:0x%08x, pname:0x%08x, params:0x%08x)", light, pname, params);
	AEMU_SCOPED_TRACE("glLightxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLineWidthx_enc(void *self , GLfixed width)
{
	ENCODER_DEBUG_LOG("glLineWidthx(width:0x%08x)", width);
	AEMU_SCOPED_TRACE("glLineWidthx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLineWidthx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &width, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLoadIdentity_enc(void *self )
{
	ENCODER_DEBUG_LOG("glLoadIdentity()");
	AEMU_SCOPED_TRACE("glLoadIdentity encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLoadIdentity;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLoadMatrixx_enc(void *self , const GLfixed* m)
{
	ENCODER_DEBUG_LOG("glLoadMatrixx(m:0x%08x)", m);
	AEMU_SCOPED_TRACE("glLoadMatrixx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_m =  (16 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_m + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLoadMatrixx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_m, 4); ptr += 4;
	memcpy(ptr, m, __size_m);ptr += __size_m;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLogicOp_enc(void *self , GLenum opcode)
{
	ENCODER_DEBUG_LOG("glLogicOp(opcode:0x%08x)", opcode);
	AEMU_SCOPED_TRACE("glLogicOp encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLogicOp;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &opcode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMaterialx_enc(void *self , GLenum face, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glMaterialx(face:0x%08x, pname:0x%08x, param:0x%08x)", face, pname, param);
	AEMU_SCOPED_TRACE("glMaterialx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMaterialx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMaterialxv_enc(void *self , GLenum face, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glMaterialxv(face:0x%08x, pname:0x%08x, params:0x%08x)", face, pname, params);
	AEMU_SCOPED_TRACE("glMaterialxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMaterialxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMatrixMode_enc(void *self , GLenum mode)
{
	ENCODER_DEBUG_LOG("glMatrixMode(mode:0x%08x)", mode);
	AEMU_SCOPED_TRACE("glMatrixMode encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMatrixMode;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMultMatrixx_enc(void *self , const GLfixed* m)
{
	ENCODER_DEBUG_LOG("glMultMatrixx(m:0x%08x)", m);
	AEMU_SCOPED_TRACE("glMultMatrixx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_m =  (16 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_m + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMultMatrixx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_m, 4); ptr += 4;
	memcpy(ptr, m, __size_m);ptr += __size_m;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMultiTexCoord4x_enc(void *self , GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
	ENCODER_DEBUG_LOG("glMultiTexCoord4x(target:0x%08x, s:0x%08x, t:0x%08x, r:0x%08x, q:0x%08x)", target, s, t, r, q);
	AEMU_SCOPED_TRACE("glMultiTexCoord4x encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMultiTexCoord4x;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &s, 4); ptr += 4;
		memcpy(ptr, &t, 4); ptr += 4;
		memcpy(ptr, &r, 4); ptr += 4;
		memcpy(ptr, &q, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glNormal3x_enc(void *self , GLfixed nx, GLfixed ny, GLfixed nz)
{
	ENCODER_DEBUG_LOG("glNormal3x(nx:0x%08x, ny:0x%08x, nz:0x%08x)", nx, ny, nz);
	AEMU_SCOPED_TRACE("glNormal3x encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glNormal3x;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &nx, 4); ptr += 4;
		memcpy(ptr, &ny, 4); ptr += 4;
		memcpy(ptr, &nz, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glOrthox_enc(void *self , GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	ENCODER_DEBUG_LOG("glOrthox(left:0x%08x, right:0x%08x, bottom:0x%08x, top:0x%08x, zNear:0x%08x, zFar:0x%08x)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glOrthox encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glOrthox;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPixelStorei_enc(void *self , GLenum pname, GLint param)
{
	ENCODER_DEBUG_LOG("glPixelStorei(pname:0x%08x, param:%d)", pname, param);
	AEMU_SCOPED_TRACE("glPixelStorei encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPixelStorei;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointParameterx_enc(void *self , GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glPointParameterx(pname:0x%08x, param:0x%08x)", pname, param);
	AEMU_SCOPED_TRACE("glPointParameterx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointParameterx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointParameterxv_enc(void *self , GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glPointParameterxv(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glPointParameterxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointParameterxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointSizex_enc(void *self , GLfixed size)
{
	ENCODER_DEBUG_LOG("glPointSizex(size:0x%08x)", size);
	AEMU_SCOPED_TRACE("glPointSizex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointSizex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPolygonOffsetx_enc(void *self , GLfixed factor, GLfixed units)
{
	ENCODER_DEBUG_LOG("glPolygonOffsetx(factor:0x%08x, units:0x%08x)", factor, units);
	AEMU_SCOPED_TRACE("glPolygonOffsetx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPolygonOffsetx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &factor, 4); ptr += 4;
		memcpy(ptr, &units, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPopMatrix_enc(void *self )
{
	ENCODER_DEBUG_LOG("glPopMatrix()");
	AEMU_SCOPED_TRACE("glPopMatrix encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPopMatrix;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPushMatrix_enc(void *self )
{
	ENCODER_DEBUG_LOG("glPushMatrix()");
	AEMU_SCOPED_TRACE("glPushMatrix encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPushMatrix;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glReadPixels_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
{
	ENCODER_DEBUG_LOG("glReadPixels(x:%d, y:%d, width:%d, height:%d, format:0x%08x, type:0x%08x, pixels:0x%08x)", x, y, width, height, format, type, pixels);
	AEMU_SCOPED_TRACE("glReadPixels encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels =  glesv1_enc::pixelDataSize(self, width, height, format, type, 1);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glReadPixels;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	memcpy(ptr, &__size_pixels, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(pixels, __size_pixels);
	if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glReadPixels: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glRotatex_enc(void *self , GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
	ENCODER_DEBUG_LOG("glRotatex(angle:0x%08x, x:0x%08x, y:0x%08x, z:0x%08x)", angle, x, y, z);
	AEMU_SCOPED_TRACE("glRotatex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glRotatex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &angle, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glSampleCoverage_enc(void *self , GLclampf value, GLboolean invert)
{
	ENCODER_DEBUG_LOG("glSampleCoverage(value:%f, invert:%d)", value, invert);
	AEMU_SCOPED_TRACE("glSampleCoverage encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glSampleCoverage;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &value, 4); ptr += 4;
		memcpy(ptr, &invert, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glSampleCoveragex_enc(void *self , GLclampx value, GLboolean invert)
{
	ENCODER_DEBUG_LOG("glSampleCoveragex(value:0x%08x, invert:%d)", value, invert);
	AEMU_SCOPED_TRACE("glSampleCoveragex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glSampleCoveragex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &value, 4); ptr += 4;
		memcpy(ptr, &invert, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glScalex_enc(void *self , GLfixed x, GLfixed y, GLfixed z)
{
	ENCODER_DEBUG_LOG("glScalex(x:0x%08x, y:0x%08x, z:0x%08x)", x, y, z);
	AEMU_SCOPED_TRACE("glScalex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glScalex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glScissor_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height)
{
	ENCODER_DEBUG_LOG("glScissor(x:%d, y:%d, width:%d, height:%d)", x, y, width, height);
	AEMU_SCOPED_TRACE("glScissor encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glScissor;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glShadeModel_enc(void *self , GLenum mode)
{
	ENCODER_DEBUG_LOG("glShadeModel(mode:0x%08x)", mode);
	AEMU_SCOPED_TRACE("glShadeModel encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glShadeModel;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilFunc_enc(void *self , GLenum func, GLint ref, GLuint mask)
{
	ENCODER_DEBUG_LOG("glStencilFunc(func:0x%08x, ref:%d, mask:%u)", func, ref, mask);
	AEMU_SCOPED_TRACE("glStencilFunc encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilFunc;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;
		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilMask_enc(void *self , GLuint mask)
{
	ENCODER_DEBUG_LOG("glStencilMask(mask:%u)", mask);
	AEMU_SCOPED_TRACE("glStencilMask encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilMask;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glStencilOp_enc(void *self , GLenum fail, GLenum zfail, GLenum zpass)
{
	ENCODER_DEBUG_LOG("glStencilOp(fail:0x%08x, zfail:0x%08x, zpass:0x%08x)", fail, zfail, zpass);
	AEMU_SCOPED_TRACE("glStencilOp encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStencilOp;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &fail, 4); ptr += 4;
		memcpy(ptr, &zfail, 4); ptr += 4;
		memcpy(ptr, &zpass, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnvi_enc(void *self , GLenum target, GLenum pname, GLint param)
{
	ENCODER_DEBUG_LOG("glTexEnvi(target:0x%08x, pname:0x%08x, param:%d)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexEnvi encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnvi;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnvx_enc(void *self , GLenum target, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glTexEnvx(target:0x%08x, pname:0x%08x, param:0x%08x)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexEnvx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnvx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnviv_enc(void *self , GLenum target, GLenum pname, const GLint* params)
{
	ENCODER_DEBUG_LOG("glTexEnviv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexEnviv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnviv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnvxv_enc(void *self , GLenum target, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glTexEnvxv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexEnvxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnvxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexImage2D_enc(void *self , GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{
	ENCODER_DEBUG_LOG("glTexImage2D(target:0x%08x, level:%d, internalformat:%d, width:%d, height:%d, border:%d, format:0x%08x, type:0x%08x, pixels:0x%08x)", target, level, internalformat, width, height, border, format, type, pixels);
	AEMU_SCOPED_TRACE("glTexImage2D encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels = ((pixels != NULL) ?  glesv1_enc::pixelDataSize(self, width, height, format, type, 0) : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glTexImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &border, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_pixels,4);
	if (pixels != NULL) {
		stream->writeFully(pixels, __size_pixels);
		if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glTexParameteri_enc(void *self , GLenum target, GLenum pname, GLint param)
{
	ENCODER_DEBUG_LOG("glTexParameteri(target:0x%08x, pname:0x%08x, param:%d)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexParameteri encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameteri;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameterx_enc(void *self , GLenum target, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glTexParameterx(target:0x%08x, pname:0x%08x, param:0x%08x)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexParameterx encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterx;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameteriv_enc(void *self , GLenum target, GLenum pname, const GLint* params)
{
	ENCODER_DEBUG_LOG("glTexParameteriv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexParameteriv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameteriv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameterxv_enc(void *self , GLenum target, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glTexParameterxv(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexParameterxv encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterxv;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexSubImage2D_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels)
{
	ENCODER_DEBUG_LOG("glTexSubImage2D(target:0x%08x, level:%d, xoffset:%d, yoffset:%d, width:%d, height:%d, format:0x%08x, type:0x%08x, pixels:0x%08x)", target, level, xoffset, yoffset, width, height, format, type, pixels);
	AEMU_SCOPED_TRACE("glTexSubImage2D encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_pixels = ((pixels != NULL) ?  glesv1_enc::pixelDataSize(self, width, height, format, type, 0) : 0);
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + __size_pixels + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
	ptr = buf;
	int tmp = OP_glTexSubImage2D;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	stream->flush();
	stream->writeFully(&__size_pixels,4);
	if (useChecksum) checksumCalculator->addBuffer(&__size_pixels,4);
	if (pixels != NULL) {
		stream->writeFully(pixels, __size_pixels);
		if (useChecksum) checksumCalculator->addBuffer(pixels, __size_pixels);
	}
	buf = stream->alloc(checksumSize);
	if (useChecksum) checksumCalculator->writeChecksum(buf, checksumSize);

}

void glTranslatex_enc(void *self , GLfixed x, GLfixed y, GLfixed z)
{
	ENCODER_DEBUG_LOG("glTranslatex(x:0x%08x, y:0x%08x, z:0x%08x)", x, y, z);
	AEMU_SCOPED_TRACE("glTranslatex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTranslatex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glViewport_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height)
{
	ENCODER_DEBUG_LOG("glViewport(x:%d, y:%d, width:%d, height:%d)", x, y, width, height);
	AEMU_SCOPED_TRACE("glViewport encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glViewport;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexPointerOffset_enc(void *self , GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	ENCODER_DEBUG_LOG("glVertexPointerOffset(size:%d, type:0x%08x, stride:%d, offset:%u)", size, type, stride, offset);
	AEMU_SCOPED_TRACE("glVertexPointerOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColorPointerOffset_enc(void *self , GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	ENCODER_DEBUG_LOG("glColorPointerOffset(size:%d, type:0x%08x, stride:%d, offset:%u)", size, type, stride, offset);
	AEMU_SCOPED_TRACE("glColorPointerOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColorPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glNormalPointerOffset_enc(void *self , GLenum type, GLsizei stride, GLuint offset)
{
	ENCODER_DEBUG_LOG("glNormalPointerOffset(type:0x%08x, stride:%d, offset:%u)", type, stride, offset);
	AEMU_SCOPED_TRACE("glNormalPointerOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glNormalPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointSizePointerOffset_enc(void *self , GLenum type, GLsizei stride, GLuint offset)
{
	ENCODER_DEBUG_LOG("glPointSizePointerOffset(type:0x%08x, stride:%d, offset:%u)", type, stride, offset);
	AEMU_SCOPED_TRACE("glPointSizePointerOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointSizePointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexCoordPointerOffset_enc(void *self , GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	ENCODER_DEBUG_LOG("glTexCoordPointerOffset(size:%d, type:0x%08x, stride:%d, offset:%u)", size, type, stride, offset);
	AEMU_SCOPED_TRACE("glTexCoordPointerOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexCoordPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glWeightPointerOffset_enc(void *self , GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	ENCODER_DEBUG_LOG("glWeightPointerOffset(size:%d, type:0x%08x, stride:%d, offset:%u)", size, type, stride, offset);
	AEMU_SCOPED_TRACE("glWeightPointerOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glWeightPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMatrixIndexPointerOffset_enc(void *self , GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	ENCODER_DEBUG_LOG("glMatrixIndexPointerOffset(size:%d, type:0x%08x, stride:%d, offset:%u)", size, type, stride, offset);
	AEMU_SCOPED_TRACE("glMatrixIndexPointerOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMatrixIndexPointerOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glVertexPointerData_enc(void *self , GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glVertexPointerData(size:%d, type:0x%08x, stride:%d, data:0x%08x, datalen:%u)", size, type, stride, data, datalen);
	AEMU_SCOPED_TRACE("glVertexPointerData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glVertexPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, size, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColorPointerData_enc(void *self , GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glColorPointerData(size:%d, type:0x%08x, stride:%d, data:0x%08x, datalen:%u)", size, type, stride, data, datalen);
	AEMU_SCOPED_TRACE("glColorPointerData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColorPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, size, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glNormalPointerData_enc(void *self , GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glNormalPointerData(type:0x%08x, stride:%d, data:0x%08x, datalen:%u)", type, stride, data, datalen);
	AEMU_SCOPED_TRACE("glNormalPointerData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glNormalPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, 3, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexCoordPointerData_enc(void *self , GLint unit, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glTexCoordPointerData(unit:%d, size:%d, type:0x%08x, stride:%d, data:0x%08x, datalen:%u)", unit, size, type, stride, data, datalen);
	AEMU_SCOPED_TRACE("glTexCoordPointerData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexCoordPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &unit, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, size, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointSizePointerData_enc(void *self , GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glPointSizePointerData(type:0x%08x, stride:%d, data:0x%08x, datalen:%u)", type, stride, data, datalen);
	AEMU_SCOPED_TRACE("glPointSizePointerData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointSizePointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char *)data, 1, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glWeightPointerData_enc(void *self , GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glWeightPointerData(size:%d, type:0x%08x, stride:%d, data:0x%08x, datalen:%u)", size, type, stride, data, datalen);
	AEMU_SCOPED_TRACE("glWeightPointerData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glWeightPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char*)data, size, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMatrixIndexPointerData_enc(void *self , GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glMatrixIndexPointerData(size:%d, type:0x%08x, stride:%d, data:0x%08x, datalen:%u)", size, type, stride, data, datalen);
	AEMU_SCOPED_TRACE("glMatrixIndexPointerData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMatrixIndexPointerData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &stride, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	 glUtilsPackPointerData((unsigned char *)ptr, (unsigned char*)data, size, type, stride, datalen);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawElementsOffset_enc(void *self , GLenum mode, GLsizei count, GLenum type, GLuint offset)
{
	ENCODER_DEBUG_LOG("glDrawElementsOffset(mode:0x%08x, count:%d, type:0x%08x, offset:%u)", mode, count, type, offset);
	AEMU_SCOPED_TRACE("glDrawElementsOffset encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawElementsOffset;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &offset, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawElementsData_enc(void *self , GLenum mode, GLsizei count, GLenum type, void* data, GLuint datalen)
{
	ENCODER_DEBUG_LOG("glDrawElementsData(mode:0x%08x, count:%d, type:0x%08x, data:0x%08x, datalen:%u)", mode, count, type, data, datalen);
	AEMU_SCOPED_TRACE("glDrawElementsData encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  datalen;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + __size_data + 4 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawElementsData;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;
		memcpy(ptr, &count, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;
	memcpy(ptr, data, __size_data);ptr += __size_data;
		memcpy(ptr, &datalen, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetCompressedTextureFormats_enc(void *self , int count, GLint* formats)
{
	ENCODER_DEBUG_LOG("glGetCompressedTextureFormats(count:%d, formats:0x%08x)", count, formats);
	AEMU_SCOPED_TRACE("glGetCompressedTextureFormats encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_formats =  (count * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetCompressedTextureFormats;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &count, 4); ptr += 4;
	memcpy(ptr, &__size_formats, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(formats, __size_formats);
	if (useChecksum) checksumCalculator->addBuffer(formats, __size_formats);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetCompressedTextureFormats: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

int glFinishRoundTrip_enc(void *self )
{
	ENCODER_DEBUG_LOG("glFinishRoundTrip()");
	AEMU_SCOPED_TRACE("glFinishRoundTrip encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFinishRoundTrip;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	int retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glFinishRoundTrip: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glBlendEquationSeparateOES_enc(void *self , GLenum modeRGB, GLenum modeAlpha)
{
	ENCODER_DEBUG_LOG("glBlendEquationSeparateOES(modeRGB:0x%08x, modeAlpha:0x%08x)", modeRGB, modeAlpha);
	AEMU_SCOPED_TRACE("glBlendEquationSeparateOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendEquationSeparateOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &modeRGB, 4); ptr += 4;
		memcpy(ptr, &modeAlpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendFuncSeparateOES_enc(void *self , GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
	ENCODER_DEBUG_LOG("glBlendFuncSeparateOES(srcRGB:0x%08x, dstRGB:0x%08x, srcAlpha:0x%08x, dstAlpha:0x%08x)", srcRGB, dstRGB, srcAlpha, dstAlpha);
	AEMU_SCOPED_TRACE("glBlendFuncSeparateOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendFuncSeparateOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &srcRGB, 4); ptr += 4;
		memcpy(ptr, &dstRGB, 4); ptr += 4;
		memcpy(ptr, &srcAlpha, 4); ptr += 4;
		memcpy(ptr, &dstAlpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBlendEquationOES_enc(void *self , GLenum mode)
{
	ENCODER_DEBUG_LOG("glBlendEquationOES(mode:0x%08x)", mode);
	AEMU_SCOPED_TRACE("glBlendEquationOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBlendEquationOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &mode, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexsOES_enc(void *self , GLshort x, GLshort y, GLshort z, GLshort width, GLshort height)
{
	ENCODER_DEBUG_LOG("glDrawTexsOES(x:%d, y:%d, z:%d, width:%d, height:%d)", x, y, z, width, height);
	AEMU_SCOPED_TRACE("glDrawTexsOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 2 + 2 + 2 + 2 + 2;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexsOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 2); ptr += 2;
		memcpy(ptr, &y, 2); ptr += 2;
		memcpy(ptr, &z, 2); ptr += 2;
		memcpy(ptr, &width, 2); ptr += 2;
		memcpy(ptr, &height, 2); ptr += 2;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexiOES_enc(void *self , GLint x, GLint y, GLint z, GLint width, GLint height)
{
	ENCODER_DEBUG_LOG("glDrawTexiOES(x:%d, y:%d, z:%d, width:%d, height:%d)", x, y, z, width, height);
	AEMU_SCOPED_TRACE("glDrawTexiOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexiOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexxOES_enc(void *self , GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height)
{
	ENCODER_DEBUG_LOG("glDrawTexxOES(x:0x%08x, y:0x%08x, z:0x%08x, width:0x%08x, height:0x%08x)", x, y, z, width, height);
	AEMU_SCOPED_TRACE("glDrawTexxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexsvOES_enc(void *self , const GLshort* coords)
{
	ENCODER_DEBUG_LOG("glDrawTexsvOES(coords:0x%08x)", coords);
	AEMU_SCOPED_TRACE("glDrawTexsvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_coords =  (5 * sizeof(GLshort));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_coords + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexsvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_coords, 4); ptr += 4;
	memcpy(ptr, coords, __size_coords);ptr += __size_coords;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexivOES_enc(void *self , const GLint* coords)
{
	ENCODER_DEBUG_LOG("glDrawTexivOES(coords:0x%08x)", coords);
	AEMU_SCOPED_TRACE("glDrawTexivOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_coords =  (5 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_coords + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexivOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_coords, 4); ptr += 4;
	memcpy(ptr, coords, __size_coords);ptr += __size_coords;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexxvOES_enc(void *self , const GLfixed* coords)
{
	ENCODER_DEBUG_LOG("glDrawTexxvOES(coords:0x%08x)", coords);
	AEMU_SCOPED_TRACE("glDrawTexxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_coords =  (5 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_coords + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_coords, 4); ptr += 4;
	memcpy(ptr, coords, __size_coords);ptr += __size_coords;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexfOES_enc(void *self , GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height)
{
	ENCODER_DEBUG_LOG("glDrawTexfOES(x:%f, y:%f, z:%f, width:%f, height:%f)", x, y, z, width, height);
	AEMU_SCOPED_TRACE("glDrawTexfOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexfOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDrawTexfvOES_enc(void *self , const GLfloat* coords)
{
	ENCODER_DEBUG_LOG("glDrawTexfvOES(coords:0x%08x)", coords);
	AEMU_SCOPED_TRACE("glDrawTexfvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_coords =  (5 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_coords + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDrawTexfvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_coords, 4); ptr += 4;
	memcpy(ptr, coords, __size_coords);ptr += __size_coords;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEGLImageTargetTexture2DOES_enc(void *self , GLenum target, GLeglImageOES image)
{
	ENCODER_DEBUG_LOG("glEGLImageTargetTexture2DOES(target:0x%08x, image:%p)", target, image);
	AEMU_SCOPED_TRACE("glEGLImageTargetTexture2DOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEGLImageTargetTexture2DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &image, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEGLImageTargetRenderbufferStorageOES_enc(void *self , GLenum target, GLeglImageOES image)
{
	ENCODER_DEBUG_LOG("glEGLImageTargetRenderbufferStorageOES(target:0x%08x, image:%p)", target, image);
	AEMU_SCOPED_TRACE("glEGLImageTargetRenderbufferStorageOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEGLImageTargetRenderbufferStorageOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &image, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glAlphaFuncxOES_enc(void *self , GLenum func, GLclampx ref)
{
	ENCODER_DEBUG_LOG("glAlphaFuncxOES(func:0x%08x, ref:0x%08x)", func, ref);
	AEMU_SCOPED_TRACE("glAlphaFuncxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glAlphaFuncxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &func, 4); ptr += 4;
		memcpy(ptr, &ref, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearColorxOES_enc(void *self , GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
	ENCODER_DEBUG_LOG("glClearColorxOES(red:0x%08x, green:0x%08x, blue:0x%08x, alpha:0x%08x)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glClearColorxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearColorxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClearDepthxOES_enc(void *self , GLclampx depth)
{
	ENCODER_DEBUG_LOG("glClearDepthxOES(depth:0x%08x)", depth);
	AEMU_SCOPED_TRACE("glClearDepthxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearDepthxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &depth, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClipPlanexOES_enc(void *self , GLenum plane, const GLfixed* equation)
{
	ENCODER_DEBUG_LOG("glClipPlanexOES(plane:0x%08x, equation:0x%08x)", plane, equation);
	AEMU_SCOPED_TRACE("glClipPlanexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_equation =  (4 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_equation + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClipPlanexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &plane, 4); ptr += 4;
	memcpy(ptr, &__size_equation, 4); ptr += 4;
	memcpy(ptr, equation, __size_equation);ptr += __size_equation;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClipPlanexIMG_enc(void *self , GLenum plane, const GLfixed* equation)
{
	ENCODER_DEBUG_LOG("glClipPlanexIMG(plane:0x%08x, equation:0x%08x)", plane, equation);
	AEMU_SCOPED_TRACE("glClipPlanexIMG encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_equation =  (4 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_equation + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClipPlanexIMG;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &plane, 4); ptr += 4;
	memcpy(ptr, &__size_equation, 4); ptr += 4;
	memcpy(ptr, equation, __size_equation);ptr += __size_equation;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glColor4xOES_enc(void *self , GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
	ENCODER_DEBUG_LOG("glColor4xOES(red:0x%08x, green:0x%08x, blue:0x%08x, alpha:0x%08x)", red, green, blue, alpha);
	AEMU_SCOPED_TRACE("glColor4xOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glColor4xOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &red, 4); ptr += 4;
		memcpy(ptr, &green, 4); ptr += 4;
		memcpy(ptr, &blue, 4); ptr += 4;
		memcpy(ptr, &alpha, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDepthRangexOES_enc(void *self , GLclampx zNear, GLclampx zFar)
{
	ENCODER_DEBUG_LOG("glDepthRangexOES(zNear:0x%08x, zFar:0x%08x)", zNear, zFar);
	AEMU_SCOPED_TRACE("glDepthRangexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthRangexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFogxOES_enc(void *self , GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glFogxOES(pname:0x%08x, param:0x%08x)", pname, param);
	AEMU_SCOPED_TRACE("glFogxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFogxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFogxvOES_enc(void *self , GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glFogxvOES(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glFogxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFogxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFrustumxOES_enc(void *self , GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	ENCODER_DEBUG_LOG("glFrustumxOES(left:0x%08x, right:0x%08x, bottom:0x%08x, top:0x%08x, zNear:0x%08x, zFar:0x%08x)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glFrustumxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFrustumxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetClipPlanexOES_enc(void *self , GLenum pname, GLfixed* eqn)
{
	ENCODER_DEBUG_LOG("glGetClipPlanexOES(pname:0x%08x, eqn:0x%08x)", pname, eqn);
	AEMU_SCOPED_TRACE("glGetClipPlanexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_eqn =  (4 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetClipPlanexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_eqn, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(eqn, __size_eqn);
	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetClipPlanexOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetClipPlanex_enc(void *self , GLenum pname, GLfixed* eqn)
{
	ENCODER_DEBUG_LOG("glGetClipPlanex(pname:0x%08x, eqn:0x%08x)", pname, eqn);
	AEMU_SCOPED_TRACE("glGetClipPlanex encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_eqn =  (4 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetClipPlanex;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_eqn, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(eqn, __size_eqn);
	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetClipPlanex: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetFixedvOES_enc(void *self , GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetFixedvOES(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glGetFixedvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetFixedvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetFixedvOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetLightxvOES_enc(void *self , GLenum light, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetLightxvOES(light:0x%08x, pname:0x%08x, params:0x%08x)", light, pname, params);
	AEMU_SCOPED_TRACE("glGetLightxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetLightxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetLightxvOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetMaterialxvOES_enc(void *self , GLenum face, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetMaterialxvOES(face:0x%08x, pname:0x%08x, params:0x%08x)", face, pname, params);
	AEMU_SCOPED_TRACE("glGetMaterialxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetMaterialxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetMaterialxvOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexEnvxvOES_enc(void *self , GLenum env, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetTexEnvxvOES(env:0x%08x, pname:0x%08x, params:0x%08x)", env, pname, params);
	AEMU_SCOPED_TRACE("glGetTexEnvxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexEnvxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &env, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexEnvxvOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetTexParameterxvOES_enc(void *self , GLenum target, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetTexParameterxvOES(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glGetTexParameterxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexParameterxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetTexParameterxvOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glLightModelxOES_enc(void *self , GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glLightModelxOES(pname:0x%08x, param:0x%08x)", pname, param);
	AEMU_SCOPED_TRACE("glLightModelxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightModelxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightModelxvOES_enc(void *self , GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glLightModelxvOES(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glLightModelxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightModelxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightxOES_enc(void *self , GLenum light, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glLightxOES(light:0x%08x, pname:0x%08x, param:0x%08x)", light, pname, param);
	AEMU_SCOPED_TRACE("glLightxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLightxvOES_enc(void *self , GLenum light, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glLightxvOES(light:0x%08x, pname:0x%08x, params:0x%08x)", light, pname, params);
	AEMU_SCOPED_TRACE("glLightxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLightxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &light, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLineWidthxOES_enc(void *self , GLfixed width)
{
	ENCODER_DEBUG_LOG("glLineWidthxOES(width:0x%08x)", width);
	AEMU_SCOPED_TRACE("glLineWidthxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLineWidthxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &width, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLoadMatrixxOES_enc(void *self , const GLfixed* m)
{
	ENCODER_DEBUG_LOG("glLoadMatrixxOES(m:0x%08x)", m);
	AEMU_SCOPED_TRACE("glLoadMatrixxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_m =  (16 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_m + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLoadMatrixxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_m, 4); ptr += 4;
	memcpy(ptr, m, __size_m);ptr += __size_m;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMaterialxOES_enc(void *self , GLenum face, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glMaterialxOES(face:0x%08x, pname:0x%08x, param:0x%08x)", face, pname, param);
	AEMU_SCOPED_TRACE("glMaterialxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMaterialxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMaterialxvOES_enc(void *self , GLenum face, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glMaterialxvOES(face:0x%08x, pname:0x%08x, params:0x%08x)", face, pname, params);
	AEMU_SCOPED_TRACE("glMaterialxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMaterialxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMultMatrixxOES_enc(void *self , const GLfixed* m)
{
	ENCODER_DEBUG_LOG("glMultMatrixxOES(m:0x%08x)", m);
	AEMU_SCOPED_TRACE("glMultMatrixxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_m =  (16 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + __size_m + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMultMatrixxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_m, 4); ptr += 4;
	memcpy(ptr, m, __size_m);ptr += __size_m;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glMultiTexCoord4xOES_enc(void *self , GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
	ENCODER_DEBUG_LOG("glMultiTexCoord4xOES(target:0x%08x, s:0x%08x, t:0x%08x, r:0x%08x, q:0x%08x)", target, s, t, r, q);
	AEMU_SCOPED_TRACE("glMultiTexCoord4xOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glMultiTexCoord4xOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &s, 4); ptr += 4;
		memcpy(ptr, &t, 4); ptr += 4;
		memcpy(ptr, &r, 4); ptr += 4;
		memcpy(ptr, &q, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glNormal3xOES_enc(void *self , GLfixed nx, GLfixed ny, GLfixed nz)
{
	ENCODER_DEBUG_LOG("glNormal3xOES(nx:0x%08x, ny:0x%08x, nz:0x%08x)", nx, ny, nz);
	AEMU_SCOPED_TRACE("glNormal3xOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glNormal3xOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &nx, 4); ptr += 4;
		memcpy(ptr, &ny, 4); ptr += 4;
		memcpy(ptr, &nz, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glOrthoxOES_enc(void *self , GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	ENCODER_DEBUG_LOG("glOrthoxOES(left:0x%08x, right:0x%08x, bottom:0x%08x, top:0x%08x, zNear:0x%08x, zFar:0x%08x)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glOrthoxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glOrthoxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointParameterxOES_enc(void *self , GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glPointParameterxOES(pname:0x%08x, param:0x%08x)", pname, param);
	AEMU_SCOPED_TRACE("glPointParameterxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointParameterxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointParameterxvOES_enc(void *self , GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glPointParameterxvOES(pname:0x%08x, params:0x%08x)", pname, params);
	AEMU_SCOPED_TRACE("glPointParameterxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointParameterxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPointSizexOES_enc(void *self , GLfixed size)
{
	ENCODER_DEBUG_LOG("glPointSizexOES(size:0x%08x)", size);
	AEMU_SCOPED_TRACE("glPointSizexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPointSizexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &size, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glPolygonOffsetxOES_enc(void *self , GLfixed factor, GLfixed units)
{
	ENCODER_DEBUG_LOG("glPolygonOffsetxOES(factor:0x%08x, units:0x%08x)", factor, units);
	AEMU_SCOPED_TRACE("glPolygonOffsetxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glPolygonOffsetxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &factor, 4); ptr += 4;
		memcpy(ptr, &units, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glRotatexOES_enc(void *self , GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
	ENCODER_DEBUG_LOG("glRotatexOES(angle:0x%08x, x:0x%08x, y:0x%08x, z:0x%08x)", angle, x, y, z);
	AEMU_SCOPED_TRACE("glRotatexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glRotatexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &angle, 4); ptr += 4;
		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glSampleCoveragexOES_enc(void *self , GLclampx value, GLboolean invert)
{
	ENCODER_DEBUG_LOG("glSampleCoveragexOES(value:0x%08x, invert:%d)", value, invert);
	AEMU_SCOPED_TRACE("glSampleCoveragexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 1;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glSampleCoveragexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &value, 4); ptr += 4;
		memcpy(ptr, &invert, 1); ptr += 1;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glScalexOES_enc(void *self , GLfixed x, GLfixed y, GLfixed z)
{
	ENCODER_DEBUG_LOG("glScalexOES(x:0x%08x, y:0x%08x, z:0x%08x)", x, y, z);
	AEMU_SCOPED_TRACE("glScalexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glScalexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnvxOES_enc(void *self , GLenum target, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glTexEnvxOES(target:0x%08x, pname:0x%08x, param:0x%08x)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexEnvxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnvxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexEnvxvOES_enc(void *self , GLenum target, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glTexEnvxvOES(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexEnvxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexEnvxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameterxOES_enc(void *self , GLenum target, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glTexParameterxOES(target:0x%08x, pname:0x%08x, param:0x%08x)", target, pname, param);
	AEMU_SCOPED_TRACE("glTexParameterxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexParameterxvOES_enc(void *self , GLenum target, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glTexParameterxvOES(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glTexParameterxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexParameterxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTranslatexOES_enc(void *self , GLfixed x, GLfixed y, GLfixed z)
{
	ENCODER_DEBUG_LOG("glTranslatexOES(x:0x%08x, y:0x%08x, z:0x%08x)", x, y, z);
	AEMU_SCOPED_TRACE("glTranslatexOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTranslatexOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &z, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLboolean glIsRenderbufferOES_enc(void *self , GLuint renderbuffer)
{
	ENCODER_DEBUG_LOG("glIsRenderbufferOES(renderbuffer:%u)", renderbuffer);
	AEMU_SCOPED_TRACE("glIsRenderbufferOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsRenderbufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &renderbuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glIsRenderbufferOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glBindRenderbufferOES_enc(void *self , GLenum target, GLuint renderbuffer)
{
	ENCODER_DEBUG_LOG("glBindRenderbufferOES(target:0x%08x, renderbuffer:%u)", target, renderbuffer);
	AEMU_SCOPED_TRACE("glBindRenderbufferOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindRenderbufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &renderbuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteRenderbuffersOES_enc(void *self , GLsizei n, const GLuint* renderbuffers)
{
	ENCODER_DEBUG_LOG("glDeleteRenderbuffersOES(n:%d, renderbuffers:0x%08x)", n, renderbuffers);
	AEMU_SCOPED_TRACE("glDeleteRenderbuffersOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_renderbuffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteRenderbuffersOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_renderbuffers, 4); ptr += 4;
	memcpy(ptr, renderbuffers, __size_renderbuffers);ptr += __size_renderbuffers;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenRenderbuffersOES_enc(void *self , GLsizei n, GLuint* renderbuffers)
{
	ENCODER_DEBUG_LOG("glGenRenderbuffersOES(n:%d, renderbuffers:0x%08x)", n, renderbuffers);
	AEMU_SCOPED_TRACE("glGenRenderbuffersOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_renderbuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenRenderbuffersOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_renderbuffers, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(renderbuffers, __size_renderbuffers);
	if (useChecksum) checksumCalculator->addBuffer(renderbuffers, __size_renderbuffers);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGenRenderbuffersOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glRenderbufferStorageOES_enc(void *self , GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	ENCODER_DEBUG_LOG("glRenderbufferStorageOES(target:0x%08x, internalformat:0x%08x, width:%d, height:%d)", target, internalformat, width, height);
	AEMU_SCOPED_TRACE("glRenderbufferStorageOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glRenderbufferStorageOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetRenderbufferParameterivOES_enc(void *self , GLenum target, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetRenderbufferParameterivOES(target:0x%08x, pname:0x%08x, params:0x%08x)", target, pname, params);
	AEMU_SCOPED_TRACE("glGetRenderbufferParameterivOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetRenderbufferParameterivOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetRenderbufferParameterivOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

GLboolean glIsFramebufferOES_enc(void *self , GLuint framebuffer)
{
	ENCODER_DEBUG_LOG("glIsFramebufferOES(framebuffer:%u)", framebuffer);
	AEMU_SCOPED_TRACE("glIsFramebufferOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsFramebufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &framebuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glIsFramebufferOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glBindFramebufferOES_enc(void *self , GLenum target, GLuint framebuffer)
{
	ENCODER_DEBUG_LOG("glBindFramebufferOES(target:0x%08x, framebuffer:%u)", target, framebuffer);
	AEMU_SCOPED_TRACE("glBindFramebufferOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindFramebufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &framebuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteFramebuffersOES_enc(void *self , GLsizei n, const GLuint* framebuffers)
{
	ENCODER_DEBUG_LOG("glDeleteFramebuffersOES(n:%d, framebuffers:0x%08x)", n, framebuffers);
	AEMU_SCOPED_TRACE("glDeleteFramebuffersOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_framebuffers + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteFramebuffersOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_framebuffers, 4); ptr += 4;
	memcpy(ptr, framebuffers, __size_framebuffers);ptr += __size_framebuffers;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenFramebuffersOES_enc(void *self , GLsizei n, GLuint* framebuffers)
{
	ENCODER_DEBUG_LOG("glGenFramebuffersOES(n:%d, framebuffers:0x%08x)", n, framebuffers);
	AEMU_SCOPED_TRACE("glGenFramebuffersOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_framebuffers =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenFramebuffersOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_framebuffers, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(framebuffers, __size_framebuffers);
	if (useChecksum) checksumCalculator->addBuffer(framebuffers, __size_framebuffers);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGenFramebuffersOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

GLenum glCheckFramebufferStatusOES_enc(void *self , GLenum target)
{
	ENCODER_DEBUG_LOG("glCheckFramebufferStatusOES(target:0x%08x)", target);
	AEMU_SCOPED_TRACE("glCheckFramebufferStatusOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCheckFramebufferStatusOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLenum retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glCheckFramebufferStatusOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glFramebufferRenderbufferOES_enc(void *self , GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	ENCODER_DEBUG_LOG("glFramebufferRenderbufferOES(target:0x%08x, attachment:0x%08x, renderbuffertarget:0x%08x, renderbuffer:%u)", target, attachment, renderbuffertarget, renderbuffer);
	AEMU_SCOPED_TRACE("glFramebufferRenderbufferOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFramebufferRenderbufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &renderbuffertarget, 4); ptr += 4;
		memcpy(ptr, &renderbuffer, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFramebufferTexture2DOES_enc(void *self , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	ENCODER_DEBUG_LOG("glFramebufferTexture2DOES(target:0x%08x, attachment:0x%08x, textarget:0x%08x, texture:%u, level:%d)", target, attachment, textarget, texture, level);
	AEMU_SCOPED_TRACE("glFramebufferTexture2DOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFramebufferTexture2DOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &textarget, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetFramebufferAttachmentParameterivOES_enc(void *self , GLenum target, GLenum attachment, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetFramebufferAttachmentParameterivOES(target:0x%08x, attachment:0x%08x, pname:0x%08x, params:0x%08x)", target, attachment, pname, params);
	AEMU_SCOPED_TRACE("glGetFramebufferAttachmentParameterivOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetFramebufferAttachmentParameterivOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetFramebufferAttachmentParameterivOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGenerateMipmapOES_enc(void *self , GLenum target)
{
	ENCODER_DEBUG_LOG("glGenerateMipmapOES(target:0x%08x)", target);
	AEMU_SCOPED_TRACE("glGenerateMipmapOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenerateMipmapOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLboolean glUnmapBufferOES_enc(void *self , GLenum target)
{
	ENCODER_DEBUG_LOG("glUnmapBufferOES(target:0x%08x)", target);
	AEMU_SCOPED_TRACE("glUnmapBufferOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glUnmapBufferOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glUnmapBufferOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glCurrentPaletteMatrixOES_enc(void *self , GLuint matrixpaletteindex)
{
	ENCODER_DEBUG_LOG("glCurrentPaletteMatrixOES(matrixpaletteindex:%u)", matrixpaletteindex);
	AEMU_SCOPED_TRACE("glCurrentPaletteMatrixOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glCurrentPaletteMatrixOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &matrixpaletteindex, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glLoadPaletteFromModelViewMatrixOES_enc(void *self )
{
	ENCODER_DEBUG_LOG("glLoadPaletteFromModelViewMatrixOES()");
	AEMU_SCOPED_TRACE("glLoadPaletteFromModelViewMatrixOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glLoadPaletteFromModelViewMatrixOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLbitfield glQueryMatrixxOES_enc(void *self , GLfixed* mantissa, GLint* exponent)
{
	ENCODER_DEBUG_LOG("glQueryMatrixxOES(mantissa:0x%08x, exponent:0x%08x)", mantissa, exponent);
	AEMU_SCOPED_TRACE("glQueryMatrixxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_mantissa =  (16 * sizeof(GLfixed));
	const unsigned int __size_exponent =  (16 * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glQueryMatrixxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_mantissa, 4); ptr += 4;
	memcpy(ptr, &__size_exponent, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(mantissa, __size_mantissa);
	if (useChecksum) checksumCalculator->addBuffer(mantissa, __size_mantissa);
	stream->readback(exponent, __size_exponent);
	if (useChecksum) checksumCalculator->addBuffer(exponent, __size_exponent);

	GLbitfield retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glQueryMatrixxOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glDepthRangefOES_enc(void *self , GLclampf zNear, GLclampf zFar)
{
	ENCODER_DEBUG_LOG("glDepthRangefOES(zNear:%f, zFar:%f)", zNear, zFar);
	AEMU_SCOPED_TRACE("glDepthRangefOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDepthRangefOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFrustumfOES_enc(void *self , GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	ENCODER_DEBUG_LOG("glFrustumfOES(left:%f, right:%f, bottom:%f, top:%f, zNear:%f, zFar:%f)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glFrustumfOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFrustumfOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glOrthofOES_enc(void *self , GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	ENCODER_DEBUG_LOG("glOrthofOES(left:%f, right:%f, bottom:%f, top:%f, zNear:%f, zFar:%f)", left, right, bottom, top, zNear, zFar);
	AEMU_SCOPED_TRACE("glOrthofOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glOrthofOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &left, 4); ptr += 4;
		memcpy(ptr, &right, 4); ptr += 4;
		memcpy(ptr, &bottom, 4); ptr += 4;
		memcpy(ptr, &top, 4); ptr += 4;
		memcpy(ptr, &zNear, 4); ptr += 4;
		memcpy(ptr, &zFar, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClipPlanefOES_enc(void *self , GLenum plane, const GLfloat* equation)
{
	ENCODER_DEBUG_LOG("glClipPlanefOES(plane:0x%08x, equation:0x%08x)", plane, equation);
	AEMU_SCOPED_TRACE("glClipPlanefOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_equation =  (4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_equation + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClipPlanefOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &plane, 4); ptr += 4;
	memcpy(ptr, &__size_equation, 4); ptr += 4;
	memcpy(ptr, equation, __size_equation);ptr += __size_equation;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glClipPlanefIMG_enc(void *self , GLenum plane, const GLfloat* equation)
{
	ENCODER_DEBUG_LOG("glClipPlanefIMG(plane:0x%08x, equation:0x%08x)", plane, equation);
	AEMU_SCOPED_TRACE("glClipPlanefIMG encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_equation =  (4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_equation + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClipPlanefIMG;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &plane, 4); ptr += 4;
	memcpy(ptr, &__size_equation, 4); ptr += 4;
	memcpy(ptr, equation, __size_equation);ptr += __size_equation;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetClipPlanefOES_enc(void *self , GLenum pname, GLfloat* eqn)
{
	ENCODER_DEBUG_LOG("glGetClipPlanefOES(pname:0x%08x, eqn:0x%08x)", pname, eqn);
	AEMU_SCOPED_TRACE("glGetClipPlanefOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_eqn =  (4 * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetClipPlanefOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_eqn, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(eqn, __size_eqn);
	if (useChecksum) checksumCalculator->addBuffer(eqn, __size_eqn);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetClipPlanefOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glClearDepthfOES_enc(void *self , GLclampf depth)
{
	ENCODER_DEBUG_LOG("glClearDepthfOES(depth:%f)", depth);
	AEMU_SCOPED_TRACE("glClearDepthfOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glClearDepthfOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &depth, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexGenfOES_enc(void *self , GLenum coord, GLenum pname, GLfloat param)
{
	ENCODER_DEBUG_LOG("glTexGenfOES(coord:0x%08x, pname:0x%08x, param:%f)", coord, pname, param);
	AEMU_SCOPED_TRACE("glTexGenfOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexGenfOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexGenfvOES_enc(void *self , GLenum coord, GLenum pname, const GLfloat* params)
{
	ENCODER_DEBUG_LOG("glTexGenfvOES(coord:0x%08x, pname:0x%08x, params:0x%08x)", coord, pname, params);
	AEMU_SCOPED_TRACE("glTexGenfvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexGenfvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexGeniOES_enc(void *self , GLenum coord, GLenum pname, GLint param)
{
	ENCODER_DEBUG_LOG("glTexGeniOES(coord:0x%08x, pname:0x%08x, param:%d)", coord, pname, param);
	AEMU_SCOPED_TRACE("glTexGeniOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexGeniOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexGenivOES_enc(void *self , GLenum coord, GLenum pname, const GLint* params)
{
	ENCODER_DEBUG_LOG("glTexGenivOES(coord:0x%08x, pname:0x%08x, params:0x%08x)", coord, pname, params);
	AEMU_SCOPED_TRACE("glTexGenivOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexGenivOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexGenxOES_enc(void *self , GLenum coord, GLenum pname, GLfixed param)
{
	ENCODER_DEBUG_LOG("glTexGenxOES(coord:0x%08x, pname:0x%08x, param:0x%08x)", coord, pname, param);
	AEMU_SCOPED_TRACE("glTexGenxOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexGenxOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glTexGenxvOES_enc(void *self , GLenum coord, GLenum pname, const GLfixed* params)
{
	ENCODER_DEBUG_LOG("glTexGenxvOES(coord:0x%08x, pname:0x%08x, params:0x%08x)", coord, pname, params);
	AEMU_SCOPED_TRACE("glTexGenxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTexGenxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetTexGenfvOES_enc(void *self , GLenum coord, GLenum pname, GLfloat* params)
{
	ENCODER_DEBUG_LOG("glGetTexGenfvOES(coord:0x%08x, pname:0x%08x, params:0x%08x)", coord, pname, params);
	AEMU_SCOPED_TRACE("glGetTexGenfvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfloat));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexGenfvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetTexGenivOES_enc(void *self , GLenum coord, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetTexGenivOES(coord:0x%08x, pname:0x%08x, params:0x%08x)", coord, pname, params);
	AEMU_SCOPED_TRACE("glGetTexGenivOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexGenivOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetTexGenxvOES_enc(void *self , GLenum coord, GLenum pname, GLfixed* params)
{
	ENCODER_DEBUG_LOG("glGetTexGenxvOES(coord:0x%08x, pname:0x%08x, params:0x%08x)", coord, pname, params);
	AEMU_SCOPED_TRACE("glGetTexGenxvOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLfixed));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_params + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetTexGenxvOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &coord, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;
	memcpy(ptr, params, __size_params);ptr += __size_params;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glBindVertexArrayOES_enc(void *self , GLuint array)
{
	ENCODER_DEBUG_LOG("glBindVertexArrayOES(array:%u)", array);
	AEMU_SCOPED_TRACE("glBindVertexArrayOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glBindVertexArrayOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteVertexArraysOES_enc(void *self , GLsizei n, const GLuint* arrays)
{
	ENCODER_DEBUG_LOG("glDeleteVertexArraysOES(n:%d, arrays:0x%08x)", n, arrays);
	AEMU_SCOPED_TRACE("glDeleteVertexArraysOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_arrays =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_arrays + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteVertexArraysOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_arrays, 4); ptr += 4;
	memcpy(ptr, arrays, __size_arrays);ptr += __size_arrays;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenVertexArraysOES_enc(void *self , GLsizei n, GLuint* arrays)
{
	ENCODER_DEBUG_LOG("glGenVertexArraysOES(n:%d, arrays:0x%08x)", n, arrays);
	AEMU_SCOPED_TRACE("glGenVertexArraysOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_arrays =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenVertexArraysOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_arrays, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(arrays, __size_arrays);
	if (useChecksum) checksumCalculator->addBuffer(arrays, __size_arrays);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGenVertexArraysOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

GLboolean glIsVertexArrayOES_enc(void *self , GLuint array)
{
	ENCODER_DEBUG_LOG("glIsVertexArrayOES(array:%u)", array);
	AEMU_SCOPED_TRACE("glIsVertexArrayOES encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsVertexArrayOES;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &array, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glIsVertexArrayOES: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glDiscardFramebufferEXT_enc(void *self , GLenum target, GLsizei numAttachments, const GLenum* attachments)
{
	ENCODER_DEBUG_LOG("glDiscardFramebufferEXT(target:0x%08x, numAttachments:%d, attachments:0x%08x)", target, numAttachments, attachments);
	AEMU_SCOPED_TRACE("glDiscardFramebufferEXT encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_attachments =  (numAttachments * sizeof(const GLenum));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + __size_attachments + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDiscardFramebufferEXT;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &numAttachments, 4); ptr += 4;
	memcpy(ptr, &__size_attachments, 4); ptr += 4;
	memcpy(ptr, attachments, __size_attachments);ptr += __size_attachments;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glRenderbufferStorageMultisampleIMG_enc(void *self , GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	ENCODER_DEBUG_LOG("glRenderbufferStorageMultisampleIMG(target:0x%08x, samples:%d, internalformat:0x%08x, width:%d, height:%d)", target, samples, internalformat, width, height);
	AEMU_SCOPED_TRACE("glRenderbufferStorageMultisampleIMG encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glRenderbufferStorageMultisampleIMG;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &samples, 4); ptr += 4;
		memcpy(ptr, &internalformat, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glFramebufferTexture2DMultisampleIMG_enc(void *self , GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
	ENCODER_DEBUG_LOG("glFramebufferTexture2DMultisampleIMG(target:0x%08x, attachment:0x%08x, textarget:0x%08x, texture:%u, level:%d, samples:%d)", target, attachment, textarget, texture, level, samples);
	AEMU_SCOPED_TRACE("glFramebufferTexture2DMultisampleIMG encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFramebufferTexture2DMultisampleIMG;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &attachment, 4); ptr += 4;
		memcpy(ptr, &textarget, 4); ptr += 4;
		memcpy(ptr, &texture, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &samples, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDeleteFencesNV_enc(void *self , GLsizei n, const GLuint* fences)
{
	ENCODER_DEBUG_LOG("glDeleteFencesNV(n:%d, fences:0x%08x)", n, fences);
	AEMU_SCOPED_TRACE("glDeleteFencesNV encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_fences =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_fences + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDeleteFencesNV;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_fences, 4); ptr += 4;
	memcpy(ptr, fences, __size_fences);ptr += __size_fences;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGenFencesNV_enc(void *self , GLsizei n, GLuint* fences)
{
	ENCODER_DEBUG_LOG("glGenFencesNV(n:%d, fences:0x%08x)", n, fences);
	AEMU_SCOPED_TRACE("glGenFencesNV encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_fences =  (n * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + __size_fences + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGenFencesNV;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &n, 4); ptr += 4;
	memcpy(ptr, &__size_fences, 4); ptr += 4;
	memcpy(ptr, fences, __size_fences);ptr += __size_fences;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLboolean glIsFenceNV_enc(void *self , GLuint fence)
{
	ENCODER_DEBUG_LOG("glIsFenceNV(fence:%u)", fence);
	AEMU_SCOPED_TRACE("glIsFenceNV encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glIsFenceNV;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &fence, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glIsFenceNV: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

GLboolean glTestFenceNV_enc(void *self , GLuint fence)
{
	ENCODER_DEBUG_LOG("glTestFenceNV(fence:%u)", fence);
	AEMU_SCOPED_TRACE("glTestFenceNV encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glTestFenceNV;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &fence, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glTestFenceNV: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glGetFenceivNV_enc(void *self , GLuint fence, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glGetFenceivNV(fence:%u, pname:0x%08x, params:0x%08x)", fence, pname, params);
	AEMU_SCOPED_TRACE("glGetFenceivNV encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetFenceivNV;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &fence, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetFenceivNV: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glFinishFenceNV_enc(void *self , GLuint fence)
{
	ENCODER_DEBUG_LOG("glFinishFenceNV(fence:%u)", fence);
	AEMU_SCOPED_TRACE("glFinishFenceNV encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glFinishFenceNV;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &fence, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glSetFenceNV_enc(void *self , GLuint fence, GLenum condition)
{
	ENCODER_DEBUG_LOG("glSetFenceNV(fence:%u, condition:0x%08x)", fence, condition);
	AEMU_SCOPED_TRACE("glSetFenceNV encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glSetFenceNV;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &fence, 4); ptr += 4;
		memcpy(ptr, &condition, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glGetDriverControlsQCOM_enc(void *self , GLint* num, GLsizei size, GLuint* driverControls)
{
	ENCODER_DEBUG_LOG("glGetDriverControlsQCOM(num:0x%08x, size:%d, driverControls:0x%08x)", num, size, driverControls);
	AEMU_SCOPED_TRACE("glGetDriverControlsQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_num =  (1 * sizeof(GLint));
	const unsigned int __size_driverControls =  (size * sizeof(GLuint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetDriverControlsQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_num, 4); ptr += 4;
		memcpy(ptr, &size, 4); ptr += 4;
	memcpy(ptr, &__size_driverControls, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(num, __size_num);
	if (useChecksum) checksumCalculator->addBuffer(num, __size_num);
	stream->readback(driverControls, __size_driverControls);
	if (useChecksum) checksumCalculator->addBuffer(driverControls, __size_driverControls);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetDriverControlsQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glGetDriverControlStringQCOM_enc(void *self , GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString)
{
	ENCODER_DEBUG_LOG("glGetDriverControlStringQCOM(driverControl:%u, bufSize:%d, length:0x%08x, driverControlString:0x%08x)", driverControl, bufSize, length, driverControlString);
	AEMU_SCOPED_TRACE("glGetDriverControlStringQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_length =  (1 * sizeof(GLsizei));
	const unsigned int __size_driverControlString =  (1 * sizeof(GLchar));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 0 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetDriverControlStringQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &driverControl, 4); ptr += 4;
		memcpy(ptr, &bufSize, 4); ptr += 4;
	memcpy(ptr, &__size_length, 4); ptr += 4;
	memcpy(ptr, &__size_driverControlString, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(length, __size_length);
	if (useChecksum) checksumCalculator->addBuffer(length, __size_length);
	stream->readback(driverControlString, __size_driverControlString);
	if (useChecksum) checksumCalculator->addBuffer(driverControlString, __size_driverControlString);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetDriverControlStringQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glEnableDriverControlQCOM_enc(void *self , GLuint driverControl)
{
	ENCODER_DEBUG_LOG("glEnableDriverControlQCOM(driverControl:%u)", driverControl);
	AEMU_SCOPED_TRACE("glEnableDriverControlQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEnableDriverControlQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &driverControl, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glDisableDriverControlQCOM_enc(void *self , GLuint driverControl)
{
	ENCODER_DEBUG_LOG("glDisableDriverControlQCOM(driverControl:%u)", driverControl);
	AEMU_SCOPED_TRACE("glDisableDriverControlQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glDisableDriverControlQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &driverControl, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glExtGetTexturesQCOM_enc(void *self , GLuint* textures, GLint maxTextures, GLint* numTextures)
{
	ENCODER_DEBUG_LOG("glExtGetTexturesQCOM(textures:0x%08x, maxTextures:%d, numTextures:0x%08x)", textures, maxTextures, numTextures);
	AEMU_SCOPED_TRACE("glExtGetTexturesQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_textures =  (maxTextures * sizeof(GLuint));
	const unsigned int __size_numTextures =  (1 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetTexturesQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_textures, 4); ptr += 4;
		memcpy(ptr, &maxTextures, 4); ptr += 4;
	memcpy(ptr, &__size_numTextures, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(textures, __size_textures);
	if (useChecksum) checksumCalculator->addBuffer(textures, __size_textures);
	stream->readback(numTextures, __size_numTextures);
	if (useChecksum) checksumCalculator->addBuffer(numTextures, __size_numTextures);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetTexturesQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glExtGetBuffersQCOM_enc(void *self , GLuint* buffers, GLint maxBuffers, GLint* numBuffers)
{
	ENCODER_DEBUG_LOG("glExtGetBuffersQCOM(buffers:0x%08x, maxBuffers:%d, numBuffers:0x%08x)", buffers, maxBuffers, numBuffers);
	AEMU_SCOPED_TRACE("glExtGetBuffersQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_buffers =  (maxBuffers * sizeof(GLuint));
	const unsigned int __size_numBuffers =  (1 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetBuffersQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_buffers, 4); ptr += 4;
		memcpy(ptr, &maxBuffers, 4); ptr += 4;
	memcpy(ptr, &__size_numBuffers, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(buffers, __size_buffers);
	if (useChecksum) checksumCalculator->addBuffer(buffers, __size_buffers);
	stream->readback(numBuffers, __size_numBuffers);
	if (useChecksum) checksumCalculator->addBuffer(numBuffers, __size_numBuffers);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetBuffersQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glExtGetRenderbuffersQCOM_enc(void *self , GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers)
{
	ENCODER_DEBUG_LOG("glExtGetRenderbuffersQCOM(renderbuffers:0x%08x, maxRenderbuffers:%d, numRenderbuffers:0x%08x)", renderbuffers, maxRenderbuffers, numRenderbuffers);
	AEMU_SCOPED_TRACE("glExtGetRenderbuffersQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_renderbuffers =  (maxRenderbuffers * sizeof(GLuint));
	const unsigned int __size_numRenderbuffers =  (1 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetRenderbuffersQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_renderbuffers, 4); ptr += 4;
		memcpy(ptr, &maxRenderbuffers, 4); ptr += 4;
	memcpy(ptr, &__size_numRenderbuffers, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(renderbuffers, __size_renderbuffers);
	if (useChecksum) checksumCalculator->addBuffer(renderbuffers, __size_renderbuffers);
	stream->readback(numRenderbuffers, __size_numRenderbuffers);
	if (useChecksum) checksumCalculator->addBuffer(numRenderbuffers, __size_numRenderbuffers);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetRenderbuffersQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glExtGetFramebuffersQCOM_enc(void *self , GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers)
{
	ENCODER_DEBUG_LOG("glExtGetFramebuffersQCOM(framebuffers:0x%08x, maxFramebuffers:%d, numFramebuffers:0x%08x)", framebuffers, maxFramebuffers, numFramebuffers);
	AEMU_SCOPED_TRACE("glExtGetFramebuffersQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_framebuffers =  (maxFramebuffers * sizeof(GLuint));
	const unsigned int __size_numFramebuffers =  (1 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetFramebuffersQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_framebuffers, 4); ptr += 4;
		memcpy(ptr, &maxFramebuffers, 4); ptr += 4;
	memcpy(ptr, &__size_numFramebuffers, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(framebuffers, __size_framebuffers);
	if (useChecksum) checksumCalculator->addBuffer(framebuffers, __size_framebuffers);
	stream->readback(numFramebuffers, __size_numFramebuffers);
	if (useChecksum) checksumCalculator->addBuffer(numFramebuffers, __size_numFramebuffers);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetFramebuffersQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glExtGetTexLevelParameterivQCOM_enc(void *self , GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params)
{
	ENCODER_DEBUG_LOG("glExtGetTexLevelParameterivQCOM(texture:%u, face:0x%08x, level:%d, pname:0x%08x, params:0x%08x)", texture, face, level, pname, params);
	AEMU_SCOPED_TRACE("glExtGetTexLevelParameterivQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_params =  (glUtilsParamSize(pname) * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetTexLevelParameterivQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &texture, 4); ptr += 4;
		memcpy(ptr, &face, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
	memcpy(ptr, &__size_params, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(params, __size_params);
	if (useChecksum) checksumCalculator->addBuffer(params, __size_params);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetTexLevelParameterivQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glExtTexObjectStateOverrideiQCOM_enc(void *self , GLenum target, GLenum pname, GLint param)
{
	ENCODER_DEBUG_LOG("glExtTexObjectStateOverrideiQCOM(target:0x%08x, pname:0x%08x, param:%d)", target, pname, param);
	AEMU_SCOPED_TRACE("glExtTexObjectStateOverrideiQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtTexObjectStateOverrideiQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &pname, 4); ptr += 4;
		memcpy(ptr, &param, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glExtGetTexSubImageQCOM_enc(void *self , GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid* texels)
{
	ENCODER_DEBUG_LOG("glExtGetTexSubImageQCOM(target:0x%08x, level:%d, xoffset:%d, yoffset:%d, zoffset:%d, width:%d, height:%d, depth:%d, format:0x%08x, type:0x%08x, texels:0x%08x)", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
	AEMU_SCOPED_TRACE("glExtGetTexSubImageQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_texels =  (depth * glesv1_enc::pixelDataSize(self, width, height, format, type, 0));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetTexSubImageQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &target, 4); ptr += 4;
		memcpy(ptr, &level, 4); ptr += 4;
		memcpy(ptr, &xoffset, 4); ptr += 4;
		memcpy(ptr, &yoffset, 4); ptr += 4;
		memcpy(ptr, &zoffset, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &depth, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
	memcpy(ptr, &__size_texels, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(texels, __size_texels);
	if (useChecksum) checksumCalculator->addBuffer(texels, __size_texels);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetTexSubImageQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glExtGetShadersQCOM_enc(void *self , GLuint* shaders, GLint maxShaders, GLint* numShaders)
{
	ENCODER_DEBUG_LOG("glExtGetShadersQCOM(shaders:0x%08x, maxShaders:%d, numShaders:0x%08x)", shaders, maxShaders, numShaders);
	AEMU_SCOPED_TRACE("glExtGetShadersQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_shaders =  (maxShaders * sizeof(GLuint));
	const unsigned int __size_numShaders =  (1 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetShadersQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_shaders, 4); ptr += 4;
		memcpy(ptr, &maxShaders, 4); ptr += 4;
	memcpy(ptr, &__size_numShaders, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(shaders, __size_shaders);
	if (useChecksum) checksumCalculator->addBuffer(shaders, __size_shaders);
	stream->readback(numShaders, __size_numShaders);
	if (useChecksum) checksumCalculator->addBuffer(numShaders, __size_numShaders);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetShadersQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

void glExtGetProgramsQCOM_enc(void *self , GLuint* programs, GLint maxPrograms, GLint* numPrograms)
{
	ENCODER_DEBUG_LOG("glExtGetProgramsQCOM(programs:0x%08x, maxPrograms:%d, numPrograms:0x%08x)", programs, maxPrograms, numPrograms);
	AEMU_SCOPED_TRACE("glExtGetProgramsQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_programs =  (maxPrograms * sizeof(GLuint));
	const unsigned int __size_numPrograms =  (1 * sizeof(GLint));
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 0 + 4 + 0 + 2*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtGetProgramsQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

	memcpy(ptr, &__size_programs, 4); ptr += 4;
		memcpy(ptr, &maxPrograms, 4); ptr += 4;
	memcpy(ptr, &__size_numPrograms, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(programs, __size_programs);
	if (useChecksum) checksumCalculator->addBuffer(programs, __size_programs);
	stream->readback(numPrograms, __size_numPrograms);
	if (useChecksum) checksumCalculator->addBuffer(numPrograms, __size_numPrograms);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtGetProgramsQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

GLboolean glExtIsProgramBinaryQCOM_enc(void *self , GLuint program)
{
	ENCODER_DEBUG_LOG("glExtIsProgramBinaryQCOM(program:%u)", program);
	AEMU_SCOPED_TRACE("glExtIsProgramBinaryQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glExtIsProgramBinaryQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &program, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLboolean retval;
	stream->readback(&retval, 1);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 1);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glExtIsProgramBinaryQCOM: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glStartTilingQCOM_enc(void *self , GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
	ENCODER_DEBUG_LOG("glStartTilingQCOM(x:%u, y:%u, width:%u, height:%u, preserveMask:0x%08x)", x, y, width, height, preserveMask);
	AEMU_SCOPED_TRACE("glStartTilingQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glStartTilingQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &preserveMask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

void glEndTilingQCOM_enc(void *self , GLbitfield preserveMask)
{
	ENCODER_DEBUG_LOG("glEndTilingQCOM(preserveMask:0x%08x)", preserveMask);
	AEMU_SCOPED_TRACE("glEndTilingQCOM encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glEndTilingQCOM;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &preserveMask, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

}

GLenum glGetGraphicsResetStatusEXT_enc(void *self )
{
	ENCODER_DEBUG_LOG("glGetGraphicsResetStatusEXT()");
	AEMU_SCOPED_TRACE("glGetGraphicsResetStatusEXT encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glGetGraphicsResetStatusEXT;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;


	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;


	GLenum retval;
	stream->readback(&retval, 4);
	if (useChecksum) checksumCalculator->addBuffer(&retval, 4);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glGetGraphicsResetStatusEXT: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
	return retval;
}

void glReadnPixelsEXT_enc(void *self , GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid* data)
{
	ENCODER_DEBUG_LOG("glReadnPixelsEXT(x:%d, y:%d, width:%d, height:%d, format:0x%08x, type:0x%08x, bufSize:%d, data:0x%08x)", x, y, width, height, format, type, bufSize, data);
	AEMU_SCOPED_TRACE("glReadnPixelsEXT encode");

	gl_encoder_context_t *ctx = (gl_encoder_context_t *)self;
	IOStream *stream = ctx->m_stream;
	ChecksumCalculator *checksumCalculator = ctx->m_checksumCalculator;
	bool useChecksum = checksumCalculator->getVersion() > 0;

	const unsigned int __size_data =  bufSize;
	 unsigned char *ptr;
	 unsigned char *buf;
	 const size_t sizeWithoutChecksum = 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 0 + 1*4;
	 const size_t checksumSize = checksumCalculator->checksumByteSize();
	 const size_t totalSize = sizeWithoutChecksum + checksumSize;
	buf = stream->alloc(totalSize);
	ptr = buf;
	int tmp = OP_glReadnPixelsEXT;memcpy(ptr, &tmp, 4); ptr += 4;
	memcpy(ptr, &totalSize, 4);  ptr += 4;

		memcpy(ptr, &x, 4); ptr += 4;
		memcpy(ptr, &y, 4); ptr += 4;
		memcpy(ptr, &width, 4); ptr += 4;
		memcpy(ptr, &height, 4); ptr += 4;
		memcpy(ptr, &format, 4); ptr += 4;
		memcpy(ptr, &type, 4); ptr += 4;
		memcpy(ptr, &bufSize, 4); ptr += 4;
	memcpy(ptr, &__size_data, 4); ptr += 4;

	if (useChecksum) checksumCalculator->addBuffer(buf, ptr-buf);
	if (useChecksum) checksumCalculator->writeChecksum(ptr, checksumSize); ptr += checksumSize;

	stream->readback(data, __size_data);
	if (useChecksum) checksumCalculator->addBuffer(data, __size_data);
	if (useChecksum) {
		unsigned char *checksumBufPtr = NULL;
		unsigned char checksumBuf[ChecksumCalculator::kMaxChecksumSize];
		if (checksumSize > 0) checksumBufPtr = &checksumBuf[0];
		stream->readback(checksumBufPtr, checksumSize);
		if (!checksumCalculator->validate(checksumBufPtr, checksumSize)) {
			ALOGE("glReadnPixelsEXT: GL communication error, please report this issue to b.android.com.\n");
			abort();
		}
	}
}

}  // namespace

gl_encoder_context_t::gl_encoder_context_t(IOStream *stream, ChecksumCalculator *checksumCalculator)
{
	m_stream = stream;
	m_checksumCalculator = checksumCalculator;

	this->glAlphaFunc = &glAlphaFunc_enc;
	this->glClearColor = &glClearColor_enc;
	this->glClearDepthf = &glClearDepthf_enc;
	this->glClipPlanef = &glClipPlanef_enc;
	this->glColor4f = &glColor4f_enc;
	this->glDepthRangef = &glDepthRangef_enc;
	this->glFogf = &glFogf_enc;
	this->glFogfv = &glFogfv_enc;
	this->glFrustumf = &glFrustumf_enc;
	this->glGetClipPlanef = &glGetClipPlanef_enc;
	this->glGetFloatv = &glGetFloatv_enc;
	this->glGetLightfv = &glGetLightfv_enc;
	this->glGetMaterialfv = &glGetMaterialfv_enc;
	this->glGetTexEnvfv = &glGetTexEnvfv_enc;
	this->glGetTexParameterfv = &glGetTexParameterfv_enc;
	this->glLightModelf = &glLightModelf_enc;
	this->glLightModelfv = &glLightModelfv_enc;
	this->glLightf = &glLightf_enc;
	this->glLightfv = &glLightfv_enc;
	this->glLineWidth = &glLineWidth_enc;
	this->glLoadMatrixf = &glLoadMatrixf_enc;
	this->glMaterialf = &glMaterialf_enc;
	this->glMaterialfv = &glMaterialfv_enc;
	this->glMultMatrixf = &glMultMatrixf_enc;
	this->glMultiTexCoord4f = &glMultiTexCoord4f_enc;
	this->glNormal3f = &glNormal3f_enc;
	this->glOrthof = &glOrthof_enc;
	this->glPointParameterf = &glPointParameterf_enc;
	this->glPointParameterfv = &glPointParameterfv_enc;
	this->glPointSize = &glPointSize_enc;
	this->glPolygonOffset = &glPolygonOffset_enc;
	this->glRotatef = &glRotatef_enc;
	this->glScalef = &glScalef_enc;
	this->glTexEnvf = &glTexEnvf_enc;
	this->glTexEnvfv = &glTexEnvfv_enc;
	this->glTexParameterf = &glTexParameterf_enc;
	this->glTexParameterfv = &glTexParameterfv_enc;
	this->glTranslatef = &glTranslatef_enc;
	this->glActiveTexture = &glActiveTexture_enc;
	this->glAlphaFuncx = &glAlphaFuncx_enc;
	this->glBindBuffer = &glBindBuffer_enc;
	this->glBindTexture = &glBindTexture_enc;
	this->glBlendFunc = &glBlendFunc_enc;
	this->glBufferData = &glBufferData_enc;
	this->glBufferSubData = &glBufferSubData_enc;
	this->glClear = &glClear_enc;
	this->glClearColorx = &glClearColorx_enc;
	this->glClearDepthx = &glClearDepthx_enc;
	this->glClearStencil = &glClearStencil_enc;
	this->glClientActiveTexture = &glClientActiveTexture_enc;
	this->glColor4ub = &glColor4ub_enc;
	this->glColor4x = &glColor4x_enc;
	this->glColorMask = &glColorMask_enc;
	this->glColorPointer = (glColorPointer_client_proc_t) &enc_unsupported;
	this->glCompressedTexImage2D = &glCompressedTexImage2D_enc;
	this->glCompressedTexSubImage2D = &glCompressedTexSubImage2D_enc;
	this->glCopyTexImage2D = &glCopyTexImage2D_enc;
	this->glCopyTexSubImage2D = &glCopyTexSubImage2D_enc;
	this->glCullFace = &glCullFace_enc;
	this->glDeleteBuffers = &glDeleteBuffers_enc;
	this->glDeleteTextures = &glDeleteTextures_enc;
	this->glDepthFunc = &glDepthFunc_enc;
	this->glDepthMask = &glDepthMask_enc;
	this->glDepthRangex = &glDepthRangex_enc;
	this->glDisable = &glDisable_enc;
	this->glDisableClientState = &glDisableClientState_enc;
	this->glDrawArrays = &glDrawArrays_enc;
	this->glDrawElements = (glDrawElements_client_proc_t) &enc_unsupported;
	this->glEnable = &glEnable_enc;
	this->glEnableClientState = &glEnableClientState_enc;
	this->glFinish = &glFinish_enc;
	this->glFlush = &glFlush_enc;
	this->glFogx = &glFogx_enc;
	this->glFogxv = &glFogxv_enc;
	this->glFrontFace = &glFrontFace_enc;
	this->glFrustumx = &glFrustumx_enc;
	this->glGetBooleanv = &glGetBooleanv_enc;
	this->glGetBufferParameteriv = &glGetBufferParameteriv_enc;
	this->glClipPlanex = &glClipPlanex_enc;
	this->glGenBuffers = &glGenBuffers_enc;
	this->glGenTextures = &glGenTextures_enc;
	this->glGetError = &glGetError_enc;
	this->glGetFixedv = &glGetFixedv_enc;
	this->glGetIntegerv = &glGetIntegerv_enc;
	this->glGetLightxv = &glGetLightxv_enc;
	this->glGetMaterialxv = &glGetMaterialxv_enc;
	this->glGetPointerv = (glGetPointerv_client_proc_t) &enc_unsupported;
	this->glGetString = (glGetString_client_proc_t) &enc_unsupported;
	this->glGetTexEnviv = &glGetTexEnviv_enc;
	this->glGetTexEnvxv = &glGetTexEnvxv_enc;
	this->glGetTexParameteriv = &glGetTexParameteriv_enc;
	this->glGetTexParameterxv = &glGetTexParameterxv_enc;
	this->glHint = &glHint_enc;
	this->glIsBuffer = &glIsBuffer_enc;
	this->glIsEnabled = &glIsEnabled_enc;
	this->glIsTexture = &glIsTexture_enc;
	this->glLightModelx = &glLightModelx_enc;
	this->glLightModelxv = &glLightModelxv_enc;
	this->glLightx = &glLightx_enc;
	this->glLightxv = &glLightxv_enc;
	this->glLineWidthx = &glLineWidthx_enc;
	this->glLoadIdentity = &glLoadIdentity_enc;
	this->glLoadMatrixx = &glLoadMatrixx_enc;
	this->glLogicOp = &glLogicOp_enc;
	this->glMaterialx = &glMaterialx_enc;
	this->glMaterialxv = &glMaterialxv_enc;
	this->glMatrixMode = &glMatrixMode_enc;
	this->glMultMatrixx = &glMultMatrixx_enc;
	this->glMultiTexCoord4x = &glMultiTexCoord4x_enc;
	this->glNormal3x = &glNormal3x_enc;
	this->glNormalPointer = (glNormalPointer_client_proc_t) &enc_unsupported;
	this->glOrthox = &glOrthox_enc;
	this->glPixelStorei = &glPixelStorei_enc;
	this->glPointParameterx = &glPointParameterx_enc;
	this->glPointParameterxv = &glPointParameterxv_enc;
	this->glPointSizex = &glPointSizex_enc;
	this->glPolygonOffsetx = &glPolygonOffsetx_enc;
	this->glPopMatrix = &glPopMatrix_enc;
	this->glPushMatrix = &glPushMatrix_enc;
	this->glReadPixels = &glReadPixels_enc;
	this->glRotatex = &glRotatex_enc;
	this->glSampleCoverage = &glSampleCoverage_enc;
	this->glSampleCoveragex = &glSampleCoveragex_enc;
	this->glScalex = &glScalex_enc;
	this->glScissor = &glScissor_enc;
	this->glShadeModel = &glShadeModel_enc;
	this->glStencilFunc = &glStencilFunc_enc;
	this->glStencilMask = &glStencilMask_enc;
	this->glStencilOp = &glStencilOp_enc;
	this->glTexCoordPointer = (glTexCoordPointer_client_proc_t) &enc_unsupported;
	this->glTexEnvi = &glTexEnvi_enc;
	this->glTexEnvx = &glTexEnvx_enc;
	this->glTexEnviv = &glTexEnviv_enc;
	this->glTexEnvxv = &glTexEnvxv_enc;
	this->glTexImage2D = &glTexImage2D_enc;
	this->glTexParameteri = &glTexParameteri_enc;
	this->glTexParameterx = &glTexParameterx_enc;
	this->glTexParameteriv = &glTexParameteriv_enc;
	this->glTexParameterxv = &glTexParameterxv_enc;
	this->glTexSubImage2D = &glTexSubImage2D_enc;
	this->glTranslatex = &glTranslatex_enc;
	this->glVertexPointer = (glVertexPointer_client_proc_t) &enc_unsupported;
	this->glViewport = &glViewport_enc;
	this->glPointSizePointerOES = (glPointSizePointerOES_client_proc_t) &enc_unsupported;
	this->glVertexPointerOffset = &glVertexPointerOffset_enc;
	this->glColorPointerOffset = &glColorPointerOffset_enc;
	this->glNormalPointerOffset = &glNormalPointerOffset_enc;
	this->glPointSizePointerOffset = &glPointSizePointerOffset_enc;
	this->glTexCoordPointerOffset = &glTexCoordPointerOffset_enc;
	this->glWeightPointerOffset = &glWeightPointerOffset_enc;
	this->glMatrixIndexPointerOffset = &glMatrixIndexPointerOffset_enc;
	this->glVertexPointerData = &glVertexPointerData_enc;
	this->glColorPointerData = &glColorPointerData_enc;
	this->glNormalPointerData = &glNormalPointerData_enc;
	this->glTexCoordPointerData = &glTexCoordPointerData_enc;
	this->glPointSizePointerData = &glPointSizePointerData_enc;
	this->glWeightPointerData = &glWeightPointerData_enc;
	this->glMatrixIndexPointerData = &glMatrixIndexPointerData_enc;
	this->glDrawElementsOffset = &glDrawElementsOffset_enc;
	this->glDrawElementsData = &glDrawElementsData_enc;
	this->glGetCompressedTextureFormats = &glGetCompressedTextureFormats_enc;
	this->glFinishRoundTrip = &glFinishRoundTrip_enc;
	this->glBlendEquationSeparateOES = &glBlendEquationSeparateOES_enc;
	this->glBlendFuncSeparateOES = &glBlendFuncSeparateOES_enc;
	this->glBlendEquationOES = &glBlendEquationOES_enc;
	this->glDrawTexsOES = &glDrawTexsOES_enc;
	this->glDrawTexiOES = &glDrawTexiOES_enc;
	this->glDrawTexxOES = &glDrawTexxOES_enc;
	this->glDrawTexsvOES = &glDrawTexsvOES_enc;
	this->glDrawTexivOES = &glDrawTexivOES_enc;
	this->glDrawTexxvOES = &glDrawTexxvOES_enc;
	this->glDrawTexfOES = &glDrawTexfOES_enc;
	this->glDrawTexfvOES = &glDrawTexfvOES_enc;
	this->glEGLImageTargetTexture2DOES = &glEGLImageTargetTexture2DOES_enc;
	this->glEGLImageTargetRenderbufferStorageOES = &glEGLImageTargetRenderbufferStorageOES_enc;
	this->glAlphaFuncxOES = &glAlphaFuncxOES_enc;
	this->glClearColorxOES = &glClearColorxOES_enc;
	this->glClearDepthxOES = &glClearDepthxOES_enc;
	this->glClipPlanexOES = &glClipPlanexOES_enc;
	this->glClipPlanexIMG = &glClipPlanexIMG_enc;
	this->glColor4xOES = &glColor4xOES_enc;
	this->glDepthRangexOES = &glDepthRangexOES_enc;
	this->glFogxOES = &glFogxOES_enc;
	this->glFogxvOES = &glFogxvOES_enc;
	this->glFrustumxOES = &glFrustumxOES_enc;
	this->glGetClipPlanexOES = &glGetClipPlanexOES_enc;
	this->glGetClipPlanex = &glGetClipPlanex_enc;
	this->glGetFixedvOES = &glGetFixedvOES_enc;
	this->glGetLightxvOES = &glGetLightxvOES_enc;
	this->glGetMaterialxvOES = &glGetMaterialxvOES_enc;
	this->glGetTexEnvxvOES = &glGetTexEnvxvOES_enc;
	this->glGetTexParameterxvOES = &glGetTexParameterxvOES_enc;
	this->glLightModelxOES = &glLightModelxOES_enc;
	this->glLightModelxvOES = &glLightModelxvOES_enc;
	this->glLightxOES = &glLightxOES_enc;
	this->glLightxvOES = &glLightxvOES_enc;
	this->glLineWidthxOES = &glLineWidthxOES_enc;
	this->glLoadMatrixxOES = &glLoadMatrixxOES_enc;
	this->glMaterialxOES = &glMaterialxOES_enc;
	this->glMaterialxvOES = &glMaterialxvOES_enc;
	this->glMultMatrixxOES = &glMultMatrixxOES_enc;
	this->glMultiTexCoord4xOES = &glMultiTexCoord4xOES_enc;
	this->glNormal3xOES = &glNormal3xOES_enc;
	this->glOrthoxOES = &glOrthoxOES_enc;
	this->glPointParameterxOES = &glPointParameterxOES_enc;
	this->glPointParameterxvOES = &glPointParameterxvOES_enc;
	this->glPointSizexOES = &glPointSizexOES_enc;
	this->glPolygonOffsetxOES = &glPolygonOffsetxOES_enc;
	this->glRotatexOES = &glRotatexOES_enc;
	this->glSampleCoveragexOES = &glSampleCoveragexOES_enc;
	this->glScalexOES = &glScalexOES_enc;
	this->glTexEnvxOES = &glTexEnvxOES_enc;
	this->glTexEnvxvOES = &glTexEnvxvOES_enc;
	this->glTexParameterxOES = &glTexParameterxOES_enc;
	this->glTexParameterxvOES = &glTexParameterxvOES_enc;
	this->glTranslatexOES = &glTranslatexOES_enc;
	this->glIsRenderbufferOES = &glIsRenderbufferOES_enc;
	this->glBindRenderbufferOES = &glBindRenderbufferOES_enc;
	this->glDeleteRenderbuffersOES = &glDeleteRenderbuffersOES_enc;
	this->glGenRenderbuffersOES = &glGenRenderbuffersOES_enc;
	this->glRenderbufferStorageOES = &glRenderbufferStorageOES_enc;
	this->glGetRenderbufferParameterivOES = &glGetRenderbufferParameterivOES_enc;
	this->glIsFramebufferOES = &glIsFramebufferOES_enc;
	this->glBindFramebufferOES = &glBindFramebufferOES_enc;
	this->glDeleteFramebuffersOES = &glDeleteFramebuffersOES_enc;
	this->glGenFramebuffersOES = &glGenFramebuffersOES_enc;
	this->glCheckFramebufferStatusOES = &glCheckFramebufferStatusOES_enc;
	this->glFramebufferRenderbufferOES = &glFramebufferRenderbufferOES_enc;
	this->glFramebufferTexture2DOES = &glFramebufferTexture2DOES_enc;
	this->glGetFramebufferAttachmentParameterivOES = &glGetFramebufferAttachmentParameterivOES_enc;
	this->glGenerateMipmapOES = &glGenerateMipmapOES_enc;
	this->glMapBufferOES = (glMapBufferOES_client_proc_t) &enc_unsupported;
	this->glUnmapBufferOES = &glUnmapBufferOES_enc;
	this->glGetBufferPointervOES = (glGetBufferPointervOES_client_proc_t) &enc_unsupported;
	this->glCurrentPaletteMatrixOES = &glCurrentPaletteMatrixOES_enc;
	this->glLoadPaletteFromModelViewMatrixOES = &glLoadPaletteFromModelViewMatrixOES_enc;
	this->glMatrixIndexPointerOES = (glMatrixIndexPointerOES_client_proc_t) &enc_unsupported;
	this->glWeightPointerOES = (glWeightPointerOES_client_proc_t) &enc_unsupported;
	this->glQueryMatrixxOES = &glQueryMatrixxOES_enc;
	this->glDepthRangefOES = &glDepthRangefOES_enc;
	this->glFrustumfOES = &glFrustumfOES_enc;
	this->glOrthofOES = &glOrthofOES_enc;
	this->glClipPlanefOES = &glClipPlanefOES_enc;
	this->glClipPlanefIMG = &glClipPlanefIMG_enc;
	this->glGetClipPlanefOES = &glGetClipPlanefOES_enc;
	this->glClearDepthfOES = &glClearDepthfOES_enc;
	this->glTexGenfOES = &glTexGenfOES_enc;
	this->glTexGenfvOES = &glTexGenfvOES_enc;
	this->glTexGeniOES = &glTexGeniOES_enc;
	this->glTexGenivOES = &glTexGenivOES_enc;
	this->glTexGenxOES = &glTexGenxOES_enc;
	this->glTexGenxvOES = &glTexGenxvOES_enc;
	this->glGetTexGenfvOES = &glGetTexGenfvOES_enc;
	this->glGetTexGenivOES = &glGetTexGenivOES_enc;
	this->glGetTexGenxvOES = &glGetTexGenxvOES_enc;
	this->glBindVertexArrayOES = &glBindVertexArrayOES_enc;
	this->glDeleteVertexArraysOES = &glDeleteVertexArraysOES_enc;
	this->glGenVertexArraysOES = &glGenVertexArraysOES_enc;
	this->glIsVertexArrayOES = &glIsVertexArrayOES_enc;
	this->glDiscardFramebufferEXT = &glDiscardFramebufferEXT_enc;
	this->glMultiDrawArraysEXT = (glMultiDrawArraysEXT_client_proc_t) &enc_unsupported;
	this->glMultiDrawElementsEXT = (glMultiDrawElementsEXT_client_proc_t) &enc_unsupported;
	this->glMultiDrawArraysSUN = (glMultiDrawArraysSUN_client_proc_t) &enc_unsupported;
	this->glMultiDrawElementsSUN = (glMultiDrawElementsSUN_client_proc_t) &enc_unsupported;
	this->glRenderbufferStorageMultisampleIMG = &glRenderbufferStorageMultisampleIMG_enc;
	this->glFramebufferTexture2DMultisampleIMG = &glFramebufferTexture2DMultisampleIMG_enc;
	this->glDeleteFencesNV = &glDeleteFencesNV_enc;
	this->glGenFencesNV = &glGenFencesNV_enc;
	this->glIsFenceNV = &glIsFenceNV_enc;
	this->glTestFenceNV = &glTestFenceNV_enc;
	this->glGetFenceivNV = &glGetFenceivNV_enc;
	this->glFinishFenceNV = &glFinishFenceNV_enc;
	this->glSetFenceNV = &glSetFenceNV_enc;
	this->glGetDriverControlsQCOM = &glGetDriverControlsQCOM_enc;
	this->glGetDriverControlStringQCOM = &glGetDriverControlStringQCOM_enc;
	this->glEnableDriverControlQCOM = &glEnableDriverControlQCOM_enc;
	this->glDisableDriverControlQCOM = &glDisableDriverControlQCOM_enc;
	this->glExtGetTexturesQCOM = &glExtGetTexturesQCOM_enc;
	this->glExtGetBuffersQCOM = &glExtGetBuffersQCOM_enc;
	this->glExtGetRenderbuffersQCOM = &glExtGetRenderbuffersQCOM_enc;
	this->glExtGetFramebuffersQCOM = &glExtGetFramebuffersQCOM_enc;
	this->glExtGetTexLevelParameterivQCOM = &glExtGetTexLevelParameterivQCOM_enc;
	this->glExtTexObjectStateOverrideiQCOM = &glExtTexObjectStateOverrideiQCOM_enc;
	this->glExtGetTexSubImageQCOM = &glExtGetTexSubImageQCOM_enc;
	this->glExtGetBufferPointervQCOM = (glExtGetBufferPointervQCOM_client_proc_t) &enc_unsupported;
	this->glExtGetShadersQCOM = &glExtGetShadersQCOM_enc;
	this->glExtGetProgramsQCOM = &glExtGetProgramsQCOM_enc;
	this->glExtIsProgramBinaryQCOM = &glExtIsProgramBinaryQCOM_enc;
	this->glExtGetProgramBinarySourceQCOM = (glExtGetProgramBinarySourceQCOM_client_proc_t) &enc_unsupported;
	this->glStartTilingQCOM = &glStartTilingQCOM_enc;
	this->glEndTilingQCOM = &glEndTilingQCOM_enc;
	this->glGetGraphicsResetStatusEXT = &glGetGraphicsResetStatusEXT_enc;
	this->glReadnPixelsEXT = &glReadnPixelsEXT_enc;
}

